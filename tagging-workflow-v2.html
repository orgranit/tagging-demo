<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tagging Workflow Simulator V2 - Selective Vault Removal</title>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            font-size: 14px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 500px 1fr;
            gap: 20px;
        }

        .wizard-area {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .table-area {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        h1 {
            margin-top: 0;
            color: #333;
            font-size: 24px;
        }

        h2 {
            color: #555;
            font-size: 18px;
            margin: 20px 0 10px 0;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 5px;
        }

        h3 {
            color: #666;
            font-size: 16px;
            margin: 15px 0 8px 0;
        }

        .input-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #333;
        }

        textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            resize: vertical;
            font-family: monospace;
            font-size: 13px;
            transition: border-color 0.2s, background-color 0.2s;
        }

        textarea.invalid {
            border-color: #dc3545;
            background-color: #fff5f5;
        }

        .validation-error {
            color: #dc3545;
            font-size: 12px;
            margin-top: 5px;
            font-weight: 500;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
            font-size: 13px;
        }

        th,
        td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        th {
            background-color: #f8f9fa;
            font-weight: 600;
        }

        .attachments-table input {
            width: 100%;
            border: none;
            padding: 4px;
            font-family: monospace;
            font-size: 12px;
        }

        .attachments-table select {
            width: 100%;
            border: none;
            padding: 4px;
            font-size: 12px;
            min-width: 100px;
        }

        .attachments-table th:nth-child(3),
        .attachments-table td:nth-child(3) {
            min-width: 120px;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: background-color 0.2s;
        }

        button:hover {
            opacity: 0.9;
        }

        .btn-primary {
            background-color: #007bff;
            color: white;
        }

        .btn-success {
            background-color: #28a745;
            color: white;
        }

        .btn-warning {
            background-color: #ffc107;
            color: #212529;
        }

        .btn-secondary {
            background-color: #6c757d;
            color: white;
        }

        .log-container {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 10px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
        }

        .log-entry {
            margin: 2px 0;
            padding: 2px 4px;
            border-radius: 3px;
        }

        .log-entry.pass {
            background-color: #d4edda;
            color: #155724;
        }

        .log-entry.fail {
            background-color: #f8d7da;
            color: #721c24;
        }

        .log-entry.vault-removed {
            background-color: #fff3cd;
            color: #856404;
            font-weight: bold;
        }

        .arrays-display {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
        }

        .empty-state {
            color: #6c757d;
            font-style: italic;
            text-align: center;
            padding: 20px;
        }

        .step-panel {
            margin-bottom: 20px;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            overflow: hidden;
        }

        .step-header {
            background-color: #f8f9fa;
            padding: 10px 15px;
            border-bottom: 1px solid #e9ecef;
            font-weight: 600;
            color: #495057;
        }

        .step-content {
            padding: 15px;
        }

        .removed-vaults {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 4px;
            padding: 10px;
            color: #856404;
        }

        .removed-pair {
            background-color: #f8d7da;
            color: #721c24;
        }

        .removed-pair td {
            border-color: #f5c6cb;
        }

        .add-row-btn {
            background-color: #17a2b8;
            color: white;
            font-size: 12px;
            padding: 4px 8px;
        }

        .req-link {
            color: #007bff;
            cursor: pointer;
            text-decoration: underline;
        }

        .req-link:hover {
            color: #0056b3;
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 20px;
            border-radius: 8px;
            width: 80%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 1px solid #e9ecef;
            padding-bottom: 10px;
        }

        .modal-title {
            margin: 0;
            color: #333;
        }

        .close {
            font-size: 24px;
            font-weight: bold;
            color: #aaa;
            cursor: pointer;
            border: none;
            background: none;
        }

        .close:hover {
            color: #000;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #e9ecef;
        }

        .btn-approve {
            background-color: #28a745;
            color: white;
        }

        .btn-reject {
            background-color: #dc3545;
            color: white;
        }

        /* Wizard Styles */
        .wizard-header {
            margin-bottom: 30px;
        }

        .wizard-steps {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding: 0;
            list-style: none;
        }

        .wizard-step {
            flex: 1;
            text-align: center;
            position: relative;
            padding: 10px 5px;
        }

        .wizard-step:not(:last-child):after {
            content: '';
            position: absolute;
            top: 20px;
            right: -50%;
            width: 100%;
            height: 2px;
            background-color: #e0e0e0;
            z-index: 1;
        }

        .wizard-step.active:not(:last-child):after {
            background-color: #007bff;
        }

        .wizard-step.completed:not(:last-child):after {
            background-color: #28a745;
        }

        .step-indicator {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 8px;
            font-weight: bold;
            position: relative;
            z-index: 2;
            background-color: #e0e0e0;
            color: #666;
            border: 3px solid #e0e0e0;
        }

        .wizard-step.active .step-indicator {
            background-color: #007bff;
            border-color: #007bff;
            color: white;
        }

        .wizard-step.completed .step-indicator {
            background-color: #28a745;
            border-color: #28a745;
            color: white;
        }

        .step-label {
            font-size: 12px;
            color: #666;
            font-weight: 500;
        }

        .wizard-step.active .step-label {
            color: #007bff;
            font-weight: 600;
        }

        .wizard-step.completed .step-label {
            color: #28a745;
        }

        .wizard-content {
            min-height: 400px;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 6px;
            border: 1px solid #e9ecef;
        }

        .wizard-navigation {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }

        .wizard-nav-left {
            display: flex;
            gap: 10px;
        }

        .wizard-nav-right {
            display: flex;
            gap: 10px;
        }

        /* Table Status Styling & Animations */
        .attachment-row {
            transition: all 0.3s ease;
        }

        .attachment-row.pending-add {
            background: linear-gradient(90deg, rgba(40, 167, 69, 0.1) 0%, rgba(40, 167, 69, 0.05) 100%);
            border-left: 4px solid #28a745;
            animation: pulse-add 2s infinite;
        }

        .attachment-row.pending-remove {
            background: linear-gradient(90deg, rgba(220, 53, 69, 0.1) 0%, rgba(220, 53, 69, 0.05) 100%);
            border-left: 4px solid #dc3545;
            animation: pulse-remove 2s infinite;
        }

        .attachment-row.final {
            background: rgba(0, 123, 255, 0.02);
            border-left: 4px solid transparent;
        }

        @keyframes pulse-add {

            0%,
            100% {
                box-shadow: 0 0 0 0 rgba(40, 167, 69, 0.3);
                border-left-color: #28a745;
            }

            50% {
                box-shadow: 0 0 0 4px rgba(40, 167, 69, 0.1);
                border-left-color: #34ce57;
            }
        }

        @keyframes pulse-remove {

            0%,
            100% {
                box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.3);
                border-left-color: #dc3545;
            }

            50% {
                box-shadow: 0 0 0 4px rgba(220, 53, 69, 0.1);
                border-left-color: #e85a6b;
            }
        }

        /* Status indicators */
        .status-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            min-width: 70px;
            text-align: center;
            transition: all 0.2s ease;
        }

        .status-badge.final {
            background-color: #e3f2fd;
            color: #1565c0;
            border: 1px solid #bbdefb;
        }

        .status-badge.pending-add {
            background-color: #e8f5e8;
            color: #2e7d32;
            border: 1px solid #c8e6c9;
            animation: glow-add 1.5s ease-in-out infinite alternate;
        }

        .status-badge.pending-remove {
            background-color: #ffebee;
            color: #c62828;
            border: 1px solid #ffcdd2;
            animation: glow-remove 1.5s ease-in-out infinite alternate;
        }

        @keyframes glow-add {
            from {
                box-shadow: 0 0 2px rgba(40, 167, 69, 0.3);
            }

            to {
                box-shadow: 0 0 6px rgba(40, 167, 69, 0.6);
            }
        }

        @keyframes glow-remove {
            from {
                box-shadow: 0 0 2px rgba(220, 53, 69, 0.3);
            }

            to {
                box-shadow: 0 0 6px rgba(220, 53, 69, 0.6);
            }
        }

        /* Req ID styling */
        .req-link {
            color: #007bff;
            cursor: pointer;
            text-decoration: none;
            font-weight: 600;
            padding: 2px 6px;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 11px;
            background-color: rgba(0, 123, 255, 0.1);
            border: 1px solid rgba(0, 123, 255, 0.2);
        }

        .req-link:hover {
            color: white;
            background-color: #007bff;
            border-color: #007bff;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 123, 255, 0.3);
        }

        /* Table enhancements */
        .attachments-table {
            border-collapse: separate;
            border-spacing: 0;
            overflow: hidden;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .attachments-table thead th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: 600;
            text-transform: uppercase;
            font-size: 11px;
            letter-spacing: 0.5px;
            padding: 12px 8px;
            border: none;
        }

        .attachments-table tbody tr:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        /* Animation Styles */
        .wizard-applying {
            position: relative;
            overflow: hidden;
        }

        .wizard-applying::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(40, 167, 69, 0.4), transparent);
            animation: applying-sweep 2s ease-in-out;
        }

        @keyframes applying-sweep {
            0% {
                left: -100%;
            }

            50% {
                left: 100%;
            }

            100% {
                left: 100%;
            }
        }

        .success-bounce {
            animation: success-bounce 0.6s ease-out;
        }

        @keyframes success-bounce {
            0% {
                transform: scale(1);
            }

            30% {
                transform: scale(1.05);
            }

            60% {
                transform: scale(0.95);
            }

            100% {
                transform: scale(1);
            }
        }


        /* Table row animations for different actions */
        .row-becoming-final {
            animation: becoming-final 1.2s ease-out forwards;
        }

        .row-being-removed {
            animation: being-removed 1s ease-out forwards;
        }

        .row-being-reverted {
            animation: being-reverted 1s ease-out forwards;
        }

        .row-newly-added {
            animation: newly-added 1s ease-out forwards;
        }

        @keyframes becoming-final {
            0% {
                transform: scale(1);
                background: linear-gradient(90deg, rgba(40, 167, 69, 0.3) 0%, rgba(40, 167, 69, 0.1) 100%);
                border-left: 4px solid #28a745;
            }

            30% {
                transform: scale(1.03);
                background: linear-gradient(90deg, rgba(40, 167, 69, 0.4) 0%, rgba(40, 167, 69, 0.2) 100%);
                border-left: 4px solid #34ce57;
                box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
            }

            70% {
                background: linear-gradient(90deg, rgba(40, 167, 69, 0.2) 0%, rgba(40, 167, 69, 0.1) 100%);
            }

            100% {
                transform: scale(1);
                background: rgba(0, 123, 255, 0.02);
                border-left: 4px solid transparent;
                box-shadow: none;
            }
        }

        @keyframes being-removed {
            0% {
                transform: scale(1);
                opacity: 1;
                background: linear-gradient(90deg, rgba(220, 53, 69, 0.1) 0%, rgba(220, 53, 69, 0.05) 100%);
            }

            30% {
                transform: scale(0.98);
                background: linear-gradient(90deg, rgba(220, 53, 69, 0.2) 0%, rgba(220, 53, 69, 0.1) 100%);
                border-left: 4px solid #e85a6b;
            }

            60% {
                transform: scale(0.95);
                opacity: 0.7;
                background: linear-gradient(90deg, rgba(220, 53, 69, 0.15) 0%, rgba(220, 53, 69, 0.08) 100%);
            }

            100% {
                transform: scale(0.9);
                opacity: 0;
                height: 0;
                padding: 0;
                margin: 0;
                border: none;
            }
        }

        @keyframes being-reverted {
            0% {
                transform: scale(1);
                background: linear-gradient(90deg, rgba(220, 53, 69, 0.1) 0%, rgba(220, 53, 69, 0.05) 100%);
                border-left: 4px solid #dc3545;
            }

            25% {
                transform: scale(1.02) rotateZ(-1deg);
                background: linear-gradient(90deg, rgba(255, 193, 7, 0.2) 0%, rgba(255, 193, 7, 0.1) 100%);
                border-left: 4px solid #ffc107;
            }

            50% {
                transform: scale(1) rotateZ(1deg);
                background: linear-gradient(90deg, rgba(255, 193, 7, 0.15) 0%, rgba(255, 193, 7, 0.08) 100%);
            }

            75% {
                transform: scale(1) rotateZ(-0.5deg);
                background: linear-gradient(90deg, rgba(0, 123, 255, 0.1) 0%, rgba(0, 123, 255, 0.05) 100%);
                border-left: 4px solid #007bff;
            }

            100% {
                transform: scale(1) rotateZ(0deg);
                background: rgba(0, 123, 255, 0.02);
                border-left: 4px solid transparent;
            }
        }

        @keyframes newly-added {
            0% {
                transform: scale(0.9) translateY(-10px);
                opacity: 0;
                background: rgba(40, 167, 69, 0.3);
            }

            30% {
                transform: scale(1.05) translateY(0);
                opacity: 0.8;
                background: rgba(40, 167, 69, 0.2);
                border-left: 4px solid #28a745;
            }

            60% {
                transform: scale(1.02);
                opacity: 1;
            }

            100% {
                transform: scale(1);
                opacity: 1;
                background: linear-gradient(90deg, rgba(40, 167, 69, 0.1) 0%, rgba(40, 167, 69, 0.05) 100%);
                border-left: 4px solid #28a745;
            }
        }

        /* Progress spinner for applying */
        .applying-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #28a745;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 8px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Edge Cases Simulator Styles */
        .edge-cases-section {
            margin-top: 30px;
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            border: 1px solid #e9ecef;
        }

        .edge-cases-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }

        .edge-cases-title {
            font-size: 16px;
            font-weight: 600;
            color: #495057;
            margin: 0;
            margin-right: 10px;
        }

        .refresh-edge-cases {
            background: #17a2b8;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 11px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .refresh-edge-cases:hover {
            background: #138496;
        }

        .edge-cases-list {
            display: grid;
            gap: 10px;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
        }

        .edge-case-item {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 12px;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .edge-case-item:hover {
            border-color: #007bff;
            box-shadow: 0 2px 8px rgba(0, 123, 255, 0.15);
            transform: translateY(-1px);
        }

        .edge-case-title {
            font-size: 12px;
            font-weight: 600;
            color: #007bff;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .edge-case-description {
            font-size: 13px;
            color: #495057;
            line-height: 1.4;
            margin-bottom: 8px;
        }

        .edge-case-inputs {
            font-size: 11px;
            color: #6c757d;
            background: #f8f9fa;
            border-radius: 3px;
            padding: 4px 6px;
            font-family: monospace;
        }

        .edge-case-empty {
            text-align: center;
            color: #6c757d;
            font-style: italic;
            padding: 20px;
        }

        /* Tags Table Styles */
        .tags-section {
            margin-top: 30px;
        }

        .tags-table {
            border-collapse: separate;
            border-spacing: 0;
            overflow: hidden;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .tags-table thead th {
            background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
            color: white;
            font-weight: 600;
            text-transform: uppercase;
            font-size: 11px;
            letter-spacing: 0.5px;
            padding: 12px 8px;
            border: none;
        }

        .tags-table input {
            width: 100%;
            border: none;
            padding: 4px;
            font-family: monospace;
            font-size: 12px;
        }

        .tags-table select {
            width: 100%;
            border: none;
            padding: 4px;
            font-size: 12px;
        }

        .tags-table .protected-checkbox {
            text-align: center;
        }

        .tags-table .protected-checkbox input[type="checkbox"] {
            width: auto;
            transform: scale(1.2);
        }

        .tag-status-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            min-width: 60px;
            text-align: center;
        }

        .tag-status-badge.final {
            background-color: #e8f5e8;
            color: #2e7d32;
            border: 1px solid #c8e6c9;
        }

        .tag-status-badge.pending-edit {
            background-color: #fff3e0;
            color: #ef6c00;
            border: 1px solid #ffcc02;
            animation: glow-edit 1.5s ease-in-out infinite alternate;
        }

        @keyframes glow-edit {
            from {
                box-shadow: 0 0 2px rgba(255, 152, 0, 0.3);
            }

            to {
                box-shadow: 0 0 6px rgba(255, 152, 0, 0.6);
            }
        }

        .tag-actions {
            display: flex;
            gap: 5px;
        }

        .tag-actions button {
            padding: 2px 6px;
            font-size: 10px;
        }

        /* Behavior Modal Styles */
        .behavior-modal-body {
            padding: 20px;
        }

        .workflow-diagram {
            display: flex;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            margin: 20px 0;
            gap: 10px;
        }

        .workflow-step {
            display: flex;
            align-items: center;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            min-width: 140px;
        }

        .step-number {
            background: #007bff;
            color: white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 10px;
            flex-shrink: 0;
        }

        .step-content strong {
            display: block;
            margin-bottom: 4px;
        }

        .step-content p {
            margin: 0;
            font-size: 12px;
            color: #666;
        }

        .workflow-arrow {
            font-size: 20px;
            color: #007bff;
            font-weight: bold;
        }

        .protection-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .protection-type {
            border-radius: 8px;
            padding: 15px;
        }

        .protection-type.protected {
            background: #fff3e0;
            border: 1px solid #ffcc02;
        }

        .protection-type.non-protected {
            background: #e8f5e8;
            border: 1px solid #4caf50;
        }

        .protection-type h5 {
            margin: 0 0 10px 0;
            font-size: 14px;
        }

        .protection-features .feature {
            margin: 5px 0;
            font-size: 12px;
        }

        .vault-removal-rules {
            margin: 20px 0;
        }

        .rule-item {
            display: flex;
            align-items: flex-start;
            margin: 10px 0;
            padding: 10px;
            border-radius: 6px;
        }

        .rule-item.valid {
            background: #e8f5e8;
            border-left: 4px solid #4caf50;
        }

        .rule-item.invalid {
            background: #fff5f5;
            border-left: 4px solid #f44336;
        }

        .rule-icon {
            margin-right: 10px;
            font-size: 14px;
        }

        .rule-content {
            flex: 1;
        }

        .rule-content ul {
            font-size: 12px;
        }

        .validation-rules {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .validation-category h5 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 14px;
        }

        .validation-item {
            margin: 5px 0;
            font-size: 12px;
            color: #666;
        }

        .status-legend {
            margin: 20px 0;
        }

        .status-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
        }

        .status-item .status-badge {
            margin-right: 15px;
        }

        .status-item span:last-child {
            font-size: 12px;
            color: #666;
        }

        .example-case {
            margin: 8px 0;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 4px;
            border-left: 3px solid #dee2e6;
        }

        .example-scenario {
            font-weight: 600;
            font-size: 12px;
            color: #495057;
            margin-bottom: 4px;
        }

        .example-details {
            font-size: 11px;
            color: #6c757d;
        }

        .example-details .success {
            color: #28a745;
            font-weight: 600;
        }

        .example-details .fail {
            color: #dc3545;
            font-weight: 600;
        }

        .example-details .pending {
            color: #ffc107;
            font-weight: 600;
        }

        @media (max-width: 768px) {
            .workflow-diagram {
                flex-direction: column;
            }

            .workflow-arrow {
                transform: rotate(90deg);
            }

            .protection-comparison,
            .validation-rules {
                grid-template-columns: 1fr;
            }
        }

        /* Validation Errors Modal Styles */
        .error-example {
            margin: 20px 0;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            overflow: hidden;
        }

        .error-example h5 {
            margin: 0;
            padding: 10px 15px;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            font-size: 13px;
            color: #495057;
        }

        .json-response {
            margin: 0;
            padding: 15px;
            background: #f8f9fa;
            border: none;
            font-size: 11px;
            line-height: 1.4;
            color: #495057;
            font-family: 'Monaco', 'Consolas', 'Courier New', monospace;
            white-space: pre-wrap;
            overflow-x: auto;
        }

        .validation-errors-body {
            max-height: 60vh;
            overflow-y: auto;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>Tagging Workflow Simulator V2</h1>
        <div class="behavior-section" onclick="showBehaviorModal()"
            style="background: #e3f2fd; border: 1px solid #90caf9; border-radius: 4px; padding: 10px; margin-bottom: 15px; font-size: 13px; color: #1565c0; cursor: pointer; transition: background-color 0.2s;"
            onmouseover="this.style.backgroundColor='#bbdefb'" onmouseout="this.style.backgroundColor='#e3f2fd'">
            <strong>📋 System Rules & Behavior</strong> (Click to view details) - Validation rules, sanitization logic,
            and protection-based workflows
        </div>

        <div class="api-examples-section"
            style="background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; padding: 15px; margin-bottom: 20px;">
            <div style="margin-bottom: 10px; font-weight: 600; color: #495057; font-size: 14px;">🚀 API Response
                Examples</div>
            <div class="api-buttons" style="display: flex; gap: 10px; flex-wrap: wrap;">
                <button class="btn-secondary" onclick="showValidationErrorsModal()"
                    style="font-size: 12px; padding: 6px 12px;">⚠️ Validation Errors</button>
                <button class="btn-secondary" onclick="showSanitizationResultsModal()"
                    style="font-size: 12px; padding: 6px 12px;">🔍 Sanitization Results</button>
                <button class="btn-secondary" onclick="showProtectionWorkflowsModal()"
                    style="font-size: 12px; padding: 6px 12px;">🔒 Protection Workflows</button>
                <button class="btn-secondary" onclick="showSuccessFailureModal()"
                    style="font-size: 12px; padding: 6px 12px;">✅ Success & Failure</button>
            </div>
        </div>

        <div class="main-layout">
            <div class="wizard-area">
                <div class="wizard-header">
                    <ul class="wizard-steps">
                        <li class="wizard-step active" data-step="1">
                            <div class="step-indicator">1</div>
                            <div class="step-label">Inputs</div>
                        </li>
                        <li class="wizard-step" data-step="2">
                            <div class="step-indicator">2</div>
                            <div class="step-label">Candidates</div>
                        </li>
                        <li class="wizard-step" data-step="3">
                            <div class="step-indicator">3</div>
                            <div class="step-label">Sanitization</div>
                        </li>
                        <li class="wizard-step" data-step="4">
                            <div class="step-indicator">4</div>
                            <div class="step-label">Review</div>
                        </li>
                        <li class="wizard-step" data-step="5">
                            <div class="step-indicator">5</div>
                            <div class="step-label">Apply</div>
                        </li>
                    </ul>
                </div>

                <div class="wizard-content" id="wizardContent">
                    <!-- Step 1 content loads here on page load -->
                </div>

                <div class="wizard-navigation">
                    <div class="wizard-nav-left">
                        <button class="btn-secondary" id="prevBtn" onclick="previousStep()" disabled>Previous</button>
                        <button class="btn-secondary" onclick="resetWizard()">Reset</button>
                    </div>
                    <div class="wizard-nav-right">
                        <button class="btn-primary" id="nextBtn" onclick="nextStep()">Next</button>
                    </div>
                </div>
            </div>

            <div class="table-area">
                <h2>Attachments Table</h2>
                <div id="attachmentsTableContainer">
                    <table class="attachments-table">
                        <thead>
                            <tr>
                                <th>Vault ID</th>
                                <th>Tag ID</th>
                                <th>Status</th>
                                <th>Req ID</th>
                                <th>Action</th>
                            </tr>
                        </thead>
                        <tbody id="attachmentsTableBody">
                        </tbody>
                    </table>
                    <button class="add-row-btn" onclick="addAttachmentRow()">+ Add Row</button>
                </div>

                <!-- Edge Cases Simulator - Commented Out -->
                <!--
                <div class="edge-cases-section">
                    <div class="edge-cases-header">
                        <h3 class="edge-cases-title">Edge Cases Simulator</h3>
                        <button class="refresh-edge-cases" onclick="generateEdgeCases()">🔄 Refresh</button>
                    </div>
                    <div id="edgeCasesList" class="edge-cases-list">
                        <div class="edge-case-empty">Analyzing current table state...</div>
                    </div>
                </div>
                -->

                <div class="tags-section">
                    <h2>Tags Management</h2>
                    <div id="tagsTableContainer">
                        <table class="tags-table">
                            <thead>
                                <tr>
                                    <th>Tag ID</th>
                                    <th>Label</th>
                                    <th>Protected</th>
                                    <th>Status</th>
                                    <th>Req ID</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody id="tagsTableBody">
                            </tbody>
                        </table>
                        <button class="add-row-btn" onclick="addTag()">+ Add Tag</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Request Modal -->
    <div id="requestModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title" id="modalTitle">Request Details</h3>
                <button class="close" onclick="closeRequestModal()">&times;</button>
            </div>
            <div id="modalBody">
                <!-- Request details will be populated here -->
            </div>
            <div class="modal-buttons">
                <button class="btn-approve" onclick="approveRequest()">Approve</button>
                <button class="btn-reject" onclick="rejectRequest()">Reject</button>
                <button class="btn-secondary" onclick="closeRequestModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Behavior Modal -->
    <div id="behaviorModal" class="modal">
        <div class="modal-content" style="max-width: 800px; max-height: 90vh; overflow-y: auto;">
            <div class="modal-header">
                <h3 class="modal-title">📋 Tagging System Rules</h3>
                <button class="close" onclick="closeBehaviorModal()">&times;</button>
            </div>
            <div class="behavior-modal-body">
                <div class="behavior-section-content">

                    <h4>🔒 Protection-Based Workflows</h4>
                    <div class="protection-comparison">
                        <div class="protection-type protected">
                            <h5>🔒 Protected Tags</h5>
                            <div class="protection-features">
                                <div class="feature">• Require approval for attach/detach</div>
                                <div class="feature">• Create pending requests</div>
                                <div class="feature">• Modal-based approval workflow</div>
                                <div class="feature">• Examples: compliance, kyc-required</div>
                            </div>
                        </div>
                        <div class="protection-type non-protected">
                            <h5>⚡ Non-Protected Tags</h5>
                            <div class="protection-features">
                                <div class="feature">• Apply immediately</div>
                                <div class="feature">• No approval needed</div>
                                <div class="feature">• Direct final state</div>
                                <div class="feature">• Examples: general-use</div>
                            </div>
                        </div>
                    </div>

                    <h4>🚫 Sanitization Rules</h4>
                    <div class="vault-removal-rules">
                        <div class="rule-item valid">
                            <div class="rule-icon">✅</div>
                            <div class="rule-content">
                                <strong>Vault Removed from Processing:</strong> Only when capacity would be exceeded (>3
                                attachments per vault)
                            </div>
                        </div>
                        <div class="rule-item invalid">
                            <div class="rule-icon">❌</div>
                            <div class="rule-content">
                                <strong>Individual Operations Rejected:</strong>
                                <ul style="margin: 5px 0; padding-left: 20px;">
                                    <li>Cannot add: attachment already exists as final</li>
                                    <li>Cannot add: pending request already exists for same vault-tag pair</li>
                                    <li>Cannot remove: attachment does not exist</li>
                                    <li>Cannot remove: pending request already exists for same vault-tag pair</li>
                                    <li>Cannot process: tag does not exist or is being edited</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <h4>⚙️ Input Validation Rules</h4>
                    <div class="validation-rules">
                        <div class="validation-category">
                            <h5>Array Constraints</h5>
                            <div class="validation-item">• Maximum 3 tags per add array</div>
                            <div class="validation-item">• Maximum 3 tags per remove array</div>
                            <div class="validation-item">• No duplicate tags within arrays</div>
                            <div class="validation-item">• No tag can appear in both add and remove arrays</div>
                        </div>
                        <div class="validation-category">
                            <h5>Tag Existence</h5>
                            <div class="validation-item">• All referenced tags must exist in tags table</div>
                            <div class="validation-item">• Tags with 'pending edit' status are invalid</div>
                            <div class="validation-item">• Tags being deleted are invalid</div>
                            <div class="validation-item">• Case-sensitive tag ID matching</div>
                        </div>
                    </div>

                    <h4>📎 Capacity Rules</h4>
                    <div class="validation-rules">
                        <div class="validation-category">
                            <h5>Vault Limits</h5>
                            <div class="validation-item">• Maximum 3 final attachments per vault</div>
                            <div class="validation-item">• Pending attachments count toward limit</div>
                            <div class="validation-item">• Exceeding capacity removes entire vault from processing</div>
                            <div class="validation-item">• Vault removal affects all tag operations for that vault</div>
                        </div>
                        <div class="validation-category">
                            <h5>Examples</h5>
                            <div class="example-case">
                                <div class="example-scenario">Capacity Exceeded:</div>
                                <div class="example-details">Vault v1 has 2 final + 1 pending → trying to add 2 more →
                                    <span class="fail">entire vault removed</span>
                                </div>
                            </div>
                            <div class="example-case">
                                <div class="example-scenario">Already Exists:</div>
                                <div class="example-details">Add t1 to v1, but v1-t1 already final → <span
                                        class="fail">operation rejected</span></div>
                            </div>
                            <div class="example-case">
                                <div class="example-scenario">Protected Tag:</div>
                                <div class="example-details">Add compliance tag → <span class="pending">creates pending
                                        request</span>, Add general-use tag → <span class="success">applied
                                        immediately</span></div>
                            </div>
                        </div>
                    </div>

                    <h4>🎭 Status Indicators</h4>
                    <div class="status-legend">
                        <div class="status-item">
                            <span class="status-badge final">final</span>
                            <span>Confirmed attachment</span>
                        </div>
                        <div class="status-item">
                            <span class="status-badge pending-add">pending add</span>
                            <span>Awaiting approval to attach</span>
                        </div>
                        <div class="status-item">
                            <span class="status-badge pending-remove">pending remove</span>
                            <span>Awaiting approval to detach</span>
                        </div>
                        <div class="status-item">
                            <span class="status-badge pending-edit">pending edit</span>
                            <span>Tag being modified</span>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-buttons">
                <button class="btn-secondary" onclick="closeBehaviorModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Validation Errors Modal -->
    <div id="validationErrorsModal" class="modal">
        <div class="modal-content" style="max-width: 700px; max-height: 90vh; overflow-y: auto;">
            <div class="modal-header">
                <h3 class="modal-title">⚠️ Validation Error Responses</h3>
                <button class="close" onclick="closeValidationErrorsModal()">&times;</button>
            </div>
            <div class="validation-errors-body" style="padding: 20px;">
                <p style="margin-bottom: 20px; color: #6c757d; font-size: 13px;">Examples of API validation error
                    responses (400 Bad Request) for different invalid input cases:</p>

                <div class="error-example">
                    <h5>🔢 Array Size Violations</h5>
                    <pre class="json-response">{
  "error": "validation_failed",
  "message": "Input validation failed",
  "details": [
    {
      "field": "tagsToAdd",
      "error": "array_too_large",
      "message": "Maximum 3 tags allowed, got 5",
      "value": ["t1", "t2", "t3", "t4", "t5"]
    }
  ]
}</pre>
                </div>

                <div class="error-example">
                    <h5>🎯 Invalid Vault IDs</h5>
                    <pre class="json-response">{
  "error": "validation_failed",
  "message": "Input validation failed",
  "details": [
    {
      "field": "vaults",
      "error": "invalid_vault_ids",
      "message": "Vault IDs must start with 'v': vault1, xyz",
      "invalid_vaults": ["vault1", "xyz"]
    }
  ]
}</pre>
                </div>

                <div class="error-example">
                    <h5>🚫 Tag Existence Errors</h5>
                    <pre class="json-response">{
  "error": "validation_failed",
  "message": "Input validation failed",
  "details": [
    {
      "field": "tagsToRemove",
      "error": "invalid_tags",
      "message": "Tags do not exist: t99, t100",
      "invalid_tags": ["t99", "t100"]
    }
  ]
}</pre>
                </div>

                <div class="error-example">
                    <h5>🔄 Tags Being Edited</h5>
                    <pre class="json-response">{
  "error": "validation_failed",
  "message": "Input validation failed",
  "details": [
    {
      "field": "tagsToAdd",
      "error": "tags_being_modified",
      "message": "Tags currently being edited: compliance",
      "unavailable_tags": ["compliance"]
    }
  ]
}</pre>
                </div>

                <div class="error-example">
                    <h5>⚔️ Conflicting Arrays</h5>
                    <pre class="json-response">{
  "error": "validation_failed",
  "message": "Input validation failed",
  "details": [
    {
      "field": "tags",
      "error": "conflicting_operations",
      "message": "Tags cannot be in both add and remove: t1, t2",
      "conflicting_tags": ["t1", "t2"]
    }
  ]
}</pre>
                </div>

                <div class="error-example">
                    <h5>🔄 Multiple Validation Errors</h5>
                    <pre class="json-response">{
  "error": "validation_failed",
  "message": "Multiple validation errors",
  "details": [
    {
      "field": "vaults",
      "error": "invalid_vault_ids",
      "message": "Vault IDs must start with 'v': xyz",
      "invalid_vaults": ["xyz"]
    },
    {
      "field": "tagsToAdd",
      "error": "array_too_large",
      "message": "Maximum 3 tags allowed, got 4"
    },
    {
      "field": "tagsToRemove",
      "error": "invalid_tags",
      "message": "Tags do not exist: t99",
      "invalid_tags": ["t99"]
    }
  ]
}</pre>
                </div>
            </div>
            <div class="modal-buttons">
                <button class="btn-secondary" onclick="closeValidationErrorsModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Sanitization Results Modal -->
    <div id="sanitizationResultsModal" class="modal">
        <div class="modal-content" style="max-width: 700px; max-height: 90vh; overflow-y: auto;">
            <div class="modal-header">
                <h3 class="modal-title">🔍 Sanitization Results</h3>
                <button class="close" onclick="closeSanitizationResultsModal()">&times;</button>
            </div>
            <div class="validation-errors-body" style="padding: 20px;">
                <p style="margin-bottom: 20px; color: #6c757d; font-size: 13px;">API sanitization responses (200 OK)
                    when individual operations are rejected or vaults are removed:</p>

                <div class="error-example">
                    <h5>❌ Individual Operation Rejections</h5>
                    <pre class="json-response">HTTP 200 OK
{
  "status": "partial_success",
  "message": "Some operations rejected during sanitization",
  "applied_operations": [
    {"vault": "v1", "tag": "general-use", "action": "add", "status": "final"}
  ],
  "pending_operations": [],
  "rejected_operations": [
    {"vault": "v2", "tag": "compliance", "action": "add", "reason": "attachment_already_exists"},
    {"vault": "v3", "tag": "general-use", "action": "remove", "reason": "attachment_not_found"},
    {"vault": "v4", "tag": "kyc-required", "action": "add", "reason": "pending_request_exists"},
    {"vault": "v5", "tag": "compliance", "action": "remove", "reason": "tag_being_modified"}
  ],
  "removed_vaults": []
}</pre>
                </div>

                <div class="error-example">
                    <h5>🚧 Capacity Exceeded (Vault Removal)</h5>
                    <pre class="json-response">HTTP 200 OK
{
  "status": "partial_success",
  "message": "Vaults removed due to capacity exceeded",
  "applied_operations": [
    {"vault": "v1", "tag": "general-use", "action": "add", "status": "final"}
  ],
  "pending_operations": [
    {"vault": "v2", "tag": "compliance", "action": "add", "status": "pending", "request_id": "REQ-456789"}
  ],
  "rejected_operations": [],
  "removed_vaults": [
    {"vault": "v3", "reason": "capacity_exceeded", "current_attachments": 3, "attempted_additions": 2}
  ]
}</pre>
                </div>

                <div class="error-example">
                    <h5>🔄 Mixed Rejections & Vault Removal</h5>
                    <pre class="json-response">HTTP 200 OK
{
  "status": "partial_success",
  "message": "Mixed sanitization issues occurred",
  "applied_operations": [
    {"vault": "v1", "tag": "general-use", "action": "add", "status": "final"}
  ],
  "pending_operations": [],
  "rejected_operations": [
    {"vault": "v2", "tag": "compliance", "action": "add", "reason": "attachment_already_exists"}
  ],
  "removed_vaults": [
    {"vault": "v3", "reason": "capacity_exceeded", "current_attachments": 3, "attempted_additions": 1}
  ]
}</pre>
                </div>

                <div style="background: #e3f2fd; padding: 15px; border-radius: 6px; margin-top: 20px;">
                    <h6 style="margin: 0 0 10px 0; color: #1565c0;">Rejection Reasons:</h6>
                    <div style="font-size: 12px; color: #1565c0;">
                        • <strong>attachment_already_exists:</strong> Trying to add an attachment that is already
                        final<br>
                        • <strong>attachment_not_found:</strong> Trying to remove an attachment that doesn't exist<br>
                        • <strong>pending_request_exists:</strong> Another pending request exists for the same vault-tag
                        pair<br>
                        • <strong>tag_being_modified:</strong> Tag became unavailable due to concurrent editing
                    </div>
                </div>
            </div>
            <div class="modal-buttons">
                <button class="btn-secondary" onclick="closeSanitizationResultsModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Protection Workflows Modal -->
    <div id="protectionWorkflowsModal" class="modal">
        <div class="modal-content" style="max-width: 700px; max-height: 90vh; overflow-y: auto;">
            <div class="modal-header">
                <h3 class="modal-title">🔒 Protection Workflows</h3>
                <button class="close" onclick="closeProtectionWorkflowsModal()">&times;</button>
            </div>
            <div class="validation-errors-body" style="padding: 20px;">
                <p style="margin-bottom: 20px; color: #6c757d; font-size: 13px;">API responses (200 OK) for protected vs
                    non-protected tag operations and approval workflows:</p>

                <div class="error-example">
                    <h5>🔄 Mixed Protection Levels</h5>
                    <pre class="json-response">HTTP 200 OK
{
  "status": "partial_success",
  "message": "Operations processed with mixed protection levels",
  "applied_operations": [
    {"vault": "v1", "tag": "general-use", "action": "add", "status": "final"},
    {"vault": "v2", "tag": "general-use", "action": "remove", "status": "final"}
  ],
  "pending_operations": [
    {"vault": "v3", "tag": "compliance", "action": "add", "status": "pending", "request_id": "REQ-789123"},
    {"vault": "v4", "tag": "kyc-required", "action": "remove", "status": "pending", "request_id": "REQ-789123"}
  ],
  "rejected_operations": [],
  "removed_vaults": []
}</pre>
                </div>

                <div class="error-example">
                    <h5>🔒 All Protected (Approval Required)</h5>
                    <pre class="json-response">HTTP 200 OK
{
  "status": "approval_required",
  "message": "All operations require approval",
  "applied_operations": [],
  "pending_operations": [
    {"vault": "v1", "tag": "compliance", "action": "add", "status": "pending", "request_id": "REQ-111222"},
    {"vault": "v2", "tag": "kyc-required", "action": "remove", "status": "pending", "request_id": "REQ-111222"},
    {"vault": "v3", "tag": "compliance", "action": "remove", "status": "pending", "request_id": "REQ-333444"}
  ],
  "rejected_operations": [],
  "removed_vaults": []
}</pre>
                </div>

                <div class="error-example">
                    <h5>⚡ All Non-Protected (Immediate)</h5>
                    <pre class="json-response">HTTP 200 OK
{
  "status": "success",
  "message": "All non-protected operations applied immediately",
  "applied_operations": [
    {"vault": "v1", "tag": "general-use", "action": "add", "status": "final"},
    {"vault": "v2", "tag": "general-use", "action": "remove", "status": "final"}
  ],
  "pending_operations": [],
  "rejected_operations": [],
  "removed_vaults": []
}</pre>
                </div>

                <div style="background: #fff3e0; padding: 15px; border-radius: 6px; margin-top: 20px;">
                    <h6 style="margin: 0 0 10px 0; color: #ef6c00;">Request ID Behavior:</h6>
                    <div style="font-size: 12px; color: #ef6c00;">
                        • <strong>Same request_id:</strong> Operations that can be approved/rejected together<br>
                        • <strong>Different request_id:</strong> Operations requiring separate approval workflows<br>
                        • <strong>No request_id:</strong> Non-protected operations applied immediately
                    </div>
                </div>
            </div>
            <div class="modal-buttons">
                <button class="btn-secondary" onclick="closeProtectionWorkflowsModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Success & Failure Modal -->
    <div id="successFailureModal" class="modal">
        <div class="modal-content" style="max-width: 700px; max-height: 90vh; overflow-y: auto;">
            <div class="modal-header">
                <h3 class="modal-title">✅ Success & Failure Scenarios</h3>
                <button class="close" onclick="closeSuccessFailureModal()">&times;</button>
            </div>
            <div class="validation-errors-body" style="padding: 20px;">
                <p style="margin-bottom: 20px; color: #6c757d; font-size: 13px;">API responses (200 OK) for complete
                    success and complete failure scenarios:</p>

                <div class="error-example">
                    <h5>✅ Complete Success</h5>
                    <pre class="json-response">HTTP 200 OK
{
  "status": "success",
  "message": "All operations applied successfully",
  "applied_operations": [
    {"vault": "v1", "tag": "general-use", "action": "add", "status": "final"},
    {"vault": "v2", "tag": "general-use", "action": "remove", "status": "final"},
    {"vault": "v3", "tag": "general-use", "action": "add", "status": "final"}
  ],
  "pending_operations": [],
  "rejected_operations": [],
  "removed_vaults": []
}</pre>
                </div>

                <div class="error-example">
                    <h5>❌ All Operations Rejected</h5>
                    <pre class="json-response">HTTP 200 OK
{
  "status": "no_operations_applied",
  "message": "All operations were rejected during sanitization",
  "applied_operations": [],
  "pending_operations": [],
  "rejected_operations": [
    {"vault": "v1", "tag": "compliance", "action": "add", "reason": "attachment_already_exists"},
    {"vault": "v2", "tag": "general-use", "action": "remove", "reason": "attachment_not_found"},
    {"vault": "v3", "tag": "kyc-required", "action": "add", "reason": "pending_request_exists"}
  ],
  "removed_vaults": []
}</pre>
                </div>

                <div class="error-example">
                    <h5>🚧 Everything Failed (Rejections + Vault Removal)</h5>
                    <pre class="json-response">HTTP 200 OK
{
  "status": "no_operations_applied",
  "message": "No operations could be applied",
  "applied_operations": [],
  "pending_operations": [],
  "rejected_operations": [
    {"vault": "v1", "tag": "general-use", "action": "add", "reason": "attachment_already_exists"}
  ],
  "removed_vaults": [
    {"vault": "v2", "reason": "capacity_exceeded", "current_attachments": 3, "attempted_additions": 1},
    {"vault": "v3", "reason": "capacity_exceeded", "current_attachments": 3, "attempted_additions": 2}
  ]
}</pre>
                </div>

                <div style="background: #e8f5e8; padding: 15px; border-radius: 6px; margin-top: 20px;">
                    <h6 style="margin: 0 0 10px 0; color: #2e7d32;">Status Meanings:</h6>
                    <div style="font-size: 12px; color: #2e7d32;">
                        • <strong>success:</strong> All operations completed as requested<br>
                        • <strong>no_operations_applied:</strong> Nothing could be processed due to business rules<br>
                        • All responses are 200 OK because the request was processed successfully
                    </div>
                </div>
            </div>
            <div class="modal-buttons">
                <button class="btn-secondary" onclick="closeSuccessFailureModal()">Close</button>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let currentAttachments = [];
        let currentCandidates = [];
        let currentValidPairs = [];
        let currentRemovedPairs = [];
        let currentRemovedVaults = [];
        let currentSanitizationLog = [];
        let currentModalReqId = null;
        let requestMetadata = {}; // Store request metadata by reqId
        let currentWizardStep = 1;
        const maxSteps = 5;

        // Tags management
        let currentTags = [];
        let tagRequestMetadata = {}; // Store tag request metadata by reqId

        // Initialize with starter data
        function initializeStarterData() {
            initializeTags(); // Initialize tags first
            currentAttachments = generateRandomAttachments(); // Then generate attachments using existing tags

            renderAttachmentsTable();
            clearResults();
        }

        function generateRandomAttachments() {
            const attachments = [];
            const vaultIds = ['v1', 'v2', 'v3', 'v4', 'v5'];
            // Only use existing tag IDs from the tags table
            const availableTagIds = currentTags.map(tag => tag.id);
            const statuses = ['final', 'pending add', 'pending remove'];

            // Generate 3-7 random attachments
            const numAttachments = Math.floor(Math.random() * 5) + 3;
            const usedPairs = new Set();

            for (let i = 0; i < numAttachments; i++) {
                let vaultId, tagId, pair;

                // Ensure unique vault-tag pairs
                do {
                    vaultId = vaultIds[Math.floor(Math.random() * vaultIds.length)];
                    tagId = availableTagIds[Math.floor(Math.random() * availableTagIds.length)];
                    pair = `${vaultId}:${tagId}`;
                } while (usedPairs.has(pair));

                usedPairs.add(pair);

                // Determine status - avoid pending states for non-protected tags
                let status;
                const tag = currentTags.find(t => t.id === tagId);
                const isProtected = tag && tag.isProtected;

                const statusRand = Math.random();
                if (!isProtected) {
                    // Non-protected tags should only have final status
                    status = 'final';
                } else {
                    // Protected tags can have pending states (70% final, 30% pending)
                    if (statusRand < 0.7) {
                        status = 'final';
                    } else if (statusRand < 0.85) {
                        status = 'pending add';
                    } else {
                        status = 'pending remove';
                    }
                }

                let reqId = null;

                // Add reqId for pending attachments
                if (status.startsWith('pending')) {
                    reqId = `REQ-${String(Math.floor(Math.random() * 999) + 1).padStart(3, '0')}`;

                    // Add metadata for this request
                    if (!requestMetadata[reqId]) {
                        requestMetadata[reqId] = {
                            vaults: [vaultId],
                            tagsToAdd: status === 'pending add' ? [tagId] : [],
                            tagsToRemove: status === 'pending remove' ? [tagId] : [],
                            timestamp: new Date(Date.now() - Math.random() * 7 * 24 * 60 * 60 * 1000).toISOString()
                        };
                    }
                }

                attachments.push({
                    vaultId,
                    tagId,
                    status,
                    reqId
                });
            }

            return attachments;
        }

        // Edge Cases Simulator Functions - Commented Out
        /*
        function generateEdgeCases() {
            const edgeCases = [];
            const vaults = [...new Set(currentAttachments.map(att => att.vaultId))];
            const tags = [...new Set(currentAttachments.map(att => att.tagId))];

            // Analyze current state
            const finalAttachments = currentAttachments.filter(att => att.status === 'final');
            const pendingAddAttachments = currentAttachments.filter(att => att.status === 'pending add');
            const pendingRemoveAttachments = currentAttachments.filter(att => att.status === 'pending remove');

            // Edge Case 1: Try to add existing final attachment
            if (finalAttachments.length > 0) {
                const target = finalAttachments[0];
                edgeCases.push({
                    title: 'Add Existing Final',
                    description: `Try to add ${target.tagId} to ${target.vaultId} which already exists as final`,
                    vaults: [target.vaultId],
                    addTags: [target.tagId],
                    removeTags: [],
                    expectedResult: 'Should be rejected: already exists'
                });
            }

            // Edge Case 2: Try to remove non-existent attachment
            if (vaults.length > 0 && tags.length > 0) {
                const vault = vaults[0];
                const unusedTag = `t${Math.floor(Math.random() * 1000)}`;
                edgeCases.push({
                    title: 'Remove Non-existent',
                    description: `Try to remove ${unusedTag} from ${vault} which doesn't exist`,
                    vaults: [vault],
                    addTags: [],
                    removeTags: [unusedTag],
                    expectedResult: 'Should be rejected: attachment does not exist'
                });
            }

            // Edge Case 3: Try to add to pending add attachment
            if (pendingAddAttachments.length > 0) {
                const target = pendingAddAttachments[0];
                edgeCases.push({
                    title: 'Add to Pending Add',
                    description: `Try to add ${target.tagId} to ${target.vaultId} which has pending add`,
                    vaults: [target.vaultId],
                    addTags: [target.tagId],
                    removeTags: [],
                    expectedResult: 'Should be rejected: pending request exists'
                });
            }

            // Edge Case 4: Try to remove pending add attachment
            if (pendingAddAttachments.length > 0) {
                const target = pendingAddAttachments[0];
                edgeCases.push({
                    title: 'Remove Pending Add',
                    description: `Try to remove ${target.tagId} from ${target.vaultId} which has pending add`,
                    vaults: [target.vaultId],
                    addTags: [],
                    removeTags: [target.tagId],
                    expectedResult: 'Should be rejected: pending request exists'
                });
            }

            // Edge Case 5: Try to add to pending remove attachment
            if (pendingRemoveAttachments.length > 0) {
                const target = pendingRemoveAttachments[0];
                edgeCases.push({
                    title: 'Add to Pending Remove',
                    description: `Try to add ${target.tagId} to ${target.vaultId} which has pending remove`,
                    vaults: [target.vaultId],
                    addTags: [target.tagId],
                    removeTags: [],
                    expectedResult: 'Should be rejected: pending request exists'
                });
            }

            // Edge Case 6: Try to remove pending remove attachment
            if (pendingRemoveAttachments.length > 0) {
                const target = pendingRemoveAttachments[0];
                edgeCases.push({
                    title: 'Remove Pending Remove',
                    description: `Try to remove ${target.tagId} from ${target.vaultId} which has pending remove`,
                    vaults: [target.vaultId],
                    addTags: [],
                    removeTags: [target.tagId],
                    expectedResult: 'Should be rejected: pending request exists'
                });
            }

            // Edge Case 7: Capacity limit test
            const vaultCounts = new Map();
            currentAttachments.forEach(att => {
                if (att.status !== 'pending remove') {
                    vaultCounts.set(att.vaultId, (vaultCounts.get(att.vaultId) || 0) + 1);
                }
            });
            const vaultNearCapacity = [...vaultCounts.entries()].find(([v, count]) => count === 2);
            if (vaultNearCapacity) {
                const [vault] = vaultNearCapacity;
                const newTag = `t${Math.floor(Math.random() * 1000)}`;
                edgeCases.push({
                    title: 'Test Capacity Limit',
                    description: `Try to add 2 tags to ${vault} which has 2 attachments (would exceed limit of 3)`,
                    vaults: [vault],
                    addTags: [newTag, `${newTag}x`],
                    removeTags: [],
                    expectedResult: 'Should accept first tag, then fail on capacity and purge vault'
                });
            }

            // Edge Case 8: Conflict resolution (same vault-tag in add and remove)
            if (finalAttachments.length > 0) {
                const target = finalAttachments[0];
                edgeCases.push({
                    title: 'Add/Remove Conflict',
                    description: `Try to both add and remove ${target.tagId} on ${target.vaultId} (remove should win)`,
                    vaults: [target.vaultId],
                    addTags: [target.tagId],
                    removeTags: [target.tagId],
                    expectedResult: 'Should generate only remove candidate, removing existing attachment'
                });
            }

            // Edge Case 9: Sequential vault failure
            if (vaults.length >= 2 && finalAttachments.length > 0) {
                const target = finalAttachments[0];
                const otherVault = vaults.find(v => v !== target.vaultId);
                if (otherVault) {
                    edgeCases.push({
                        title: 'Sequential Vault Failure',
                        description: `Add existing ${target.tagId} to ${target.vaultId}, then valid tag to ${otherVault}`,
                        vaults: [target.vaultId, otherVault],
                        addTags: [target.tagId],
                        removeTags: [],
                        expectedResult: `V2: Should reject pair on ${target.vaultId} (no vault removal), then succeed on ${otherVault}`
                    });
                }
            }
            
            // Edge Case 10: Mixed vault success/failure - First vault fails, others succeed
            if (vaults.length >= 3 && finalAttachments.length > 0) {
                const failingVault = finalAttachments[0].vaultId;
                const existingTag = finalAttachments[0].tagId;
                const otherVaults = vaults.filter(v => v !== failingVault).slice(0, 2);
                
                if (otherVaults.length >= 2) {
                    const newTag = `t${Math.floor(Math.random() * 1000)}`;
                    edgeCases.push({
                        title: 'First Vault Fails, Others Pass',
                        description: `Try to add existing ${existingTag} to ${failingVault} (fails), while adding ${newTag} to ${otherVaults.join(' and ')} (should succeed)`,
                        vaults: [failingVault, ...otherVaults],
                        addTags: [existingTag, newTag],
                        removeTags: [],
                        expectedResult: `V2: Should reject pairs on ${failingVault} (no vault removal), succeed on ${otherVaults.join(' and ')}`
                    });
                }
            }
            
            // Edge Case 11: Middle vault fails due to capacity
            const vaultsWithCounts = [...vaultCounts.entries()];
            const vaultAt2 = vaultsWithCounts.find(([v, count]) => count === 2);
            if (vaultAt2 && vaults.length >= 3) {
                const [capacityVault] = vaultAt2;
                const otherVaults = vaults.filter(v => v !== capacityVault).slice(0, 2);
                
                if (otherVaults.length >= 2) {
                    const newTag1 = `t${Math.floor(Math.random() * 1000)}`;
                    const newTag2 = `t${Math.floor(Math.random() * 1000) + 100}`;
                    edgeCases.push({
                        title: 'Middle Vault Capacity Failure',
                        description: `Add ${newTag1} to ${otherVaults[0]}, then 2 tags to ${capacityVault} (capacity fail), then ${newTag2} to ${otherVaults[1]}`,
                        vaults: otherVaults[0] ? [otherVaults[0], capacityVault, otherVaults[1]] : [capacityVault],
                        addTags: [newTag1, newTag1 + 'x', newTag1 + 'y', newTag2],
                        removeTags: [],
                        expectedResult: `First vault succeeds, middle vault fails on capacity and gets purged, last vault succeeds`
                    });
                }
            }
            
            // Edge Case 12: Multiple vault failures with success in between
            if (vaults.length >= 3 && finalAttachments.length >= 2) {
                const failTargets = finalAttachments.slice(0, 2);
                const successVault = vaults.find(v => !failTargets.some(f => f.vaultId === v));
                
                if (successVault && failTargets.length >= 2) {
                    const newTag = `t${Math.floor(Math.random() * 1000)}`;
                    edgeCases.push({
                        title: 'Multiple Failures With Success',
                        description: `Try to add existing tags to ${failTargets[0].vaultId} and ${failTargets[1].vaultId} (both fail), but new tag to ${successVault} (succeeds)`,
                        vaults: [failTargets[0].vaultId, successVault, failTargets[1].vaultId],
                        addTags: [failTargets[0].tagId, newTag, failTargets[1].tagId],
                        removeTags: [],
                        expectedResult: `V2: Should reject pairs on ${failTargets[0].vaultId} and ${failTargets[1].vaultId} (no vault removal), succeed on ${successVault}`
                    });
                }
            }
            
            // Edge Case 13: Pending attachment mixed with success
            if (pendingAddAttachments.length > 0 && vaults.length >= 2) {
                const pendingTarget = pendingAddAttachments[0];
                const successVault = vaults.find(v => v !== pendingTarget.vaultId);
                
                if (successVault) {
                    const newTag = `t${Math.floor(Math.random() * 1000)}`;
                    edgeCases.push({
                        title: 'Pending Conflict + Success',
                        description: `Try to add ${pendingTarget.tagId} to ${pendingTarget.vaultId} (has pending, should fail) and ${newTag} to ${successVault} (should succeed)`,
                        vaults: [pendingTarget.vaultId, successVault],
                        addTags: [pendingTarget.tagId, newTag],
                        removeTags: [],
                        expectedResult: `V2: Should reject pair on ${pendingTarget.vaultId} (no vault removal), succeed on ${successVault}`
                    });
                }
            }

            renderEdgeCases(edgeCases);
        }

        function renderEdgeCases(edgeCases) {
            const container = document.getElementById('edgeCasesList');

            if (edgeCases.length === 0) {
                container.innerHTML = '<div class="edge-case-empty">No edge cases found for current table state</div>';
                return;
            }

            container.innerHTML = edgeCases.map((edgeCase, index) => `
                <div class="edge-case-item" onclick="applyEdgeCase(${index})">
                    <div class="edge-case-title">${edgeCase.title}</div>
                    <div class="edge-case-description">${edgeCase.description}</div>
                    <div class="edge-case-inputs">
                        Vaults: [${edgeCase.vaults.join(', ')}] | 
                        Add: [${edgeCase.addTags.join(', ') || 'none'}] | 
                        Remove: [${edgeCase.removeTags.join(', ') || 'none'}]
                    </div>
                </div>
            `).join('');

            // Store edge cases globally for click handlers
            window.currentEdgeCases = edgeCases;
        }

        function applyEdgeCase(index) {
            const edgeCase = window.currentEdgeCases[index];
            if (!edgeCase) return;

            // Reset wizard state first
            resetWizard();
            
            // Set inputs
            document.getElementById('vaults').value = edgeCase.vaults.join(', ');
            document.getElementById('tagsToAdd').value = edgeCase.addTags.join(', ');
            document.getElementById('tagsToRemove').value = edgeCase.removeTags.join(', ');

            // Validate and update preview to reflect the new inputs
            setTimeout(() => validateInputs(), 50);

            // Show a brief indication
            const item = event.target.closest('.edge-case-item');
            item.style.background = '#e3f2fd';
            setTimeout(() => {
                item.style.background = 'white';
            }, 300);
        }
        */

        // Tags Management Functions
        function getTagById(tagId) {
            return currentTags.find(tag => tag.id === tagId);
        }

        function getTagLabel(tagId) {
            const tag = getTagById(tagId);
            return tag ? tag.label : tagId; // fallback to ID if tag not found
        }

        function initializeTags() {
            currentTags = [
                { id: 't1', label: 'compliance', isProtected: true, status: 'final', reqId: null },
                { id: 't2', label: 'kyc-required', isProtected: true, status: 'final', reqId: null },
                { id: 't3', label: 'general-use', isProtected: false, status: 'final', reqId: null }
            ];
            renderTagsTable();
        }

        function renderTagsTable() {
            const tbody = document.getElementById('tagsTableBody');
            tbody.innerHTML = currentTags.map((tag, index) => {
                const reqIdCell = tag.reqId ?
                    `<span class="req-link" onclick="showTagRequestModal('${tag.reqId}')">${tag.reqId}</span>` :
                    '<span style="color: #6c757d;">-</span>';

                const statusBadge = `<span class="tag-status-badge ${tag.status.replace(' ', '-')}">${tag.status}</span>`;

                const isEditable = tag.status === 'final';

                return `
                <tr>
                    <td>
                        <input type="text" value="${tag.id}" 
                               onchange="updateTag(${index}, 'id', this.value)"
                               ${!isEditable ? 'disabled' : ''} 
                               style="font-family: monospace; font-weight: 600;">
                    </td>
                    <td>
                        <input type="text" value="${tag.label}" 
                               onchange="updateTag(${index}, 'label', this.value)"
                               ${!isEditable ? 'disabled' : ''}>
                    </td>
                    <td class="protected-checkbox">
                        <input type="checkbox" ${tag.isProtected ? 'checked' : ''} 
                               disabled 
                               title="Protection status cannot be changed after creation">
                    </td>
                    <td>${statusBadge}</td>
                    <td>${reqIdCell}</td>
                    <td class="tag-actions">
                        <button class="btn-secondary" onclick="deleteTag(${index})" 
                                ${!isEditable ? 'disabled' : ''}>Delete</button>
                    </td>
                </tr>
                `;
            }).join('');
        }

        function addTag() {
            // Prompt for tag details
            const label = prompt("Enter tag label:");
            if (!label || label.trim() === '') return;

            const isProtected = confirm("Is this a protected tag?\n(Protected tags require approval for attach/detach operations)");

            // Generate unique ID
            let newId;
            do {
                newId = `t${currentTags.length + 1}`;
                // If ID exists, try with timestamp suffix
                if (currentTags.some(tag => tag.id === newId)) {
                    newId = `t${Date.now()}`;
                }
            } while (currentTags.some(tag => tag.id === newId));

            const newTag = {
                id: newId,
                label: label.trim(),
                isProtected: isProtected,
                status: 'final',
                reqId: null
            };
            currentTags.push(newTag);
            renderTagsTable();
        }

        function updateTag(index, field, value) {
            if (index < 0 || index >= currentTags.length) return;

            const tag = currentTags[index];
            const oldValue = tag[field];

            // Block isProtected changes
            if (field === 'isProtected') {
                alert('Protection status cannot be changed after tag creation.');
                renderTagsTable();
                return;
            }

            // Special validation for tag ID changes
            if (field === 'id' && oldValue !== value) {
                // Check if old ID is used in attachments
                const hasAttachments = currentAttachments.some(att => att.tagId === oldValue);
                if (hasAttachments) {
                    alert(`Cannot change tag ID "${oldValue}" - it has existing attachments. Remove attachments first or create a new tag.`);
                    renderTagsTable(); // Reset the input field
                    return;
                }

                // Check if new ID already exists
                const idExists = currentTags.some((t, i) => i !== index && t.id === value);
                if (idExists) {
                    alert(`Tag ID "${value}" already exists. Please choose a different ID.`);
                    renderTagsTable(); // Reset the input field
                    return;
                }
            }

            // If it's a protected tag being edited, create approval request
            if (tag.isProtected && tag.status === 'final' && oldValue !== value) {
                const reqId = `TAG-REQ-${String(Date.now()).slice(-6)}`;

                // Create pending edit version
                tag.status = 'pendingEdit';
                tag.reqId = reqId;

                // Store metadata for approval
                tagRequestMetadata[reqId] = {
                    tagId: tag.id,
                    field: field,
                    oldValue: oldValue,
                    newValue: value,
                    timestamp: new Date().toISOString()
                };

                alert(`Protected tag edit requires approval. Request ${reqId} created.`);
            } else if (!tag.isProtected || tag.status !== 'final') {
                // Direct update for non-protected tags or non-final status
                tag[field] = value;
            }

            renderTagsTable();
        }

        function deleteTag(index) {
            if (index < 0 || index >= currentTags.length) return;

            const tag = currentTags[index];

            // Check if tag has any attachments
            const hasAttachments = currentAttachments.some(att => att.tagId === tag.id);
            if (hasAttachments) {
                alert(`Cannot delete tag "${tag.label}" - it has existing attachments. Remove all attachments first.`);
                return;
            }

            // If it's a protected tag, create approval request
            if (tag.isProtected && tag.status === 'final') {
                const reqId = `TAG-DEL-${String(Date.now()).slice(-6)}`;

                tag.status = 'pendingEdit';
                tag.reqId = reqId;

                tagRequestMetadata[reqId] = {
                    tagId: tag.id,
                    field: 'delete',
                    oldValue: tag,
                    newValue: null,
                    timestamp: new Date().toISOString()
                };

                alert(`Protected tag deletion requires approval. Request ${reqId} created.`);
                renderTagsTable();
            } else {
                // Direct delete for non-protected tags
                currentTags.splice(index, 1);
                renderTagsTable();
            }
        }

        function showTagRequestModal(reqId) {
            const metadata = tagRequestMetadata[reqId];
            if (!metadata) return;

            currentModalReqId = reqId;
            document.getElementById('modalTitle').textContent = `Tag Request ${reqId}`;

            const modalBody = document.getElementById('modalBody');
            let actionDescription = '';

            if (metadata.field === 'delete') {
                actionDescription = `<strong>Delete Tag:</strong> "${metadata.oldValue.label}" (${metadata.oldValue.isProtected ? 'Protected' : 'Not Protected'})`;
            } else {
                actionDescription = `<strong>Edit Tag:</strong> Change ${metadata.field} from "${metadata.oldValue}" to "${metadata.newValue}"`;
            }

            modalBody.innerHTML = `
                <div style="background-color: #fff3e0; padding: 15px; margin-bottom: 20px; border-radius: 6px; border-left: 4px solid #ff9800;">
                    <h4 style="margin: 0 0 10px 0; color: #ef6c00;">Tag Modification Request</h4>
                    <div style="margin-bottom: 8px;">
                        ${actionDescription}
                    </div>
                    <div style="margin-top: 8px; font-size: 11px; color: #6c757d;">
                        Created: ${new Date(metadata.timestamp).toLocaleString()}
                    </div>
                </div>
            `;

            document.getElementById('requestModal').style.display = 'block';
        }

        function approveTagRequest() {
            if (!currentModalReqId || !currentModalReqId.startsWith('TAG-')) return;

            const reqId = currentModalReqId;
            const metadata = tagRequestMetadata[reqId];
            if (!metadata) return;

            closeRequestModal();

            // Find the tag
            const tagIndex = currentTags.findIndex(tag => tag.id === metadata.tagId);
            if (tagIndex === -1) return;

            if (metadata.field === 'delete') {
                // Delete the tag
                currentTags.splice(tagIndex, 1);
            } else {
                // Apply the edit
                const tag = currentTags[tagIndex];
                tag[metadata.field] = metadata.newValue;
                tag.status = 'final';
                tag.reqId = null;
            }

            delete tagRequestMetadata[reqId];
            renderTagsTable();
        }

        function rejectTagRequest() {
            if (!currentModalReqId || !currentModalReqId.startsWith('TAG-')) return;

            const reqId = currentModalReqId;
            const metadata = tagRequestMetadata[reqId];
            if (!metadata) return;

            closeRequestModal();

            // Find the tag and revert to final state
            const tagIndex = currentTags.findIndex(tag => tag.id === metadata.tagId);
            if (tagIndex !== -1) {
                const tag = currentTags[tagIndex];
                tag.status = 'final';
                tag.reqId = null;
            }

            delete tagRequestMetadata[reqId];
            renderTagsTable();
        }

        // Parse comma or newline separated list
        function parseList(str) {
            if (!str || typeof str !== 'string') return [];
            return str.split(/[,\n]/)
                .map(item => item.trim())
                .filter(item => item.length > 0)
                .filter((item, index, array) => array.indexOf(item) === index); // dedupe
        }

        // Build candidates with conflict resolution
        function buildCandidates(vaults, addTags, removeTags) {
            const candidates = [];
            const conflicts = new Set(); // track (vault,tag) pairs that have conflicts

            // First pass: identify conflicts
            for (const vault of vaults) {
                for (const tag of addTags) {
                    if (removeTags.includes(tag)) {
                        conflicts.add(`${vault}:${tag}`);
                    }
                }
            }

            // Second pass: generate candidates, preferring remove for conflicts
            for (const vault of vaults) {
                // Add candidates
                for (const tag of addTags) {
                    const key = `${vault}:${tag}`;
                    if (!conflicts.has(key)) {
                        candidates.push({ vaultId: vault, tagId: tag, action: 'add' });
                    }
                }

                // Remove candidates (always included, even for conflicts)
                for (const tag of removeTags) {
                    candidates.push({ vaultId: vault, tagId: tag, action: 'remove' });
                }
            }

            return candidates;
        }

        // Sanitize candidates with selective vault removal (V2 Behavior)
        function sanitizeCandidates(candidates, attachments) {
            const removedVaults = new Set();
            const validPairs = [];
            const removedPairs = [];
            const validPairCount = new Map();
            const log = [];

            for (let i = 0; i < candidates.length; i++) {
                const candidate = candidates[i];
                const { vaultId, tagId, action } = candidate;

                let isValid = true;
                let reason = '';
                let shouldRemoveVault = false;

                // Rule 1: Check if vault was removed earlier
                if (removedVaults.has(vaultId)) {
                    isValid = false;
                    reason = 'vault removed earlier';
                } else if (action === 'add') {
                    // Rule 2a: Check if attachment already exists or has pending request
                    const existingAttachment = attachments.find(att =>
                        att.vaultId === vaultId && att.tagId === tagId
                    );
                    if (existingAttachment && existingAttachment.status === 'final') {
                        isValid = false;
                        reason = 'already exists';
                        // V2: Don't remove vault, just reject this pair
                    } else if (existingAttachment && existingAttachment.status.startsWith('pending')) {
                        isValid = false;
                        reason = 'pending request exists';
                        // V2: Don't remove vault, just reject this pair
                    } else {
                        // Rule 2b: Check capacity limit (count existing + pending + current batch + this candidate)
                        const existingCount = attachments.filter(att =>
                            att.vaultId === vaultId && att.status !== 'pending remove'
                        ).length;
                        const currentBatchCount = validPairCount.get(vaultId) || 0;
                        const totalCountAfterAdding = existingCount + currentBatchCount + 1;

                        if (totalCountAfterAdding > 3) {
                            isValid = false;
                            reason = 'capacity reached (max 3)';
                            shouldRemoveVault = true; // V2: Only remove vault on capacity exceeded
                        }
                    }
                } else if (action === 'remove') {
                    // Rule 3: Can only remove existing final attachments, not pending ones
                    const existingAttachment = attachments.find(att =>
                        att.vaultId === vaultId && att.tagId === tagId
                    );
                    if (!existingAttachment) {
                        isValid = false;
                        reason = 'attachment does not exist';
                        // V2: Don't remove vault, just reject this pair
                    } else if (existingAttachment.status.startsWith('pending')) {
                        isValid = false;
                        reason = 'pending request exists';
                        // V2: Don't remove vault, just reject this pair
                    } else if (existingAttachment.status !== 'final') {
                        isValid = false;
                        reason = 'not a final attachment';
                        // V2: Don't remove vault, just reject this pair
                    }
                }

                if (isValid) {
                    // Accept the candidate
                    validPairs.push(candidate);
                    validPairCount.set(vaultId, (validPairCount.get(vaultId) || 0) + 1);
                    log.push({
                        step: i + 1,
                        candidate: candidate,
                        status: 'PASS',
                        reason: 'accepted'
                    });
                } else {
                    // Log the failure and add to removed pairs
                    removedPairs.push({...candidate, reason});
                    log.push({
                        step: i + 1,
                        candidate: candidate,
                        status: 'FAIL',
                        reason: reason
                    });

                    // V2: Only remove vault if it's a capacity issue
                    if (shouldRemoveVault && !removedVaults.has(vaultId)) {
                        // Remove vault due to capacity exceeded
                        removedVaults.add(vaultId);

                        // Purge previously accepted pairs for this vault
                        const originalLength = validPairs.length;
                        for (let j = validPairs.length - 1; j >= 0; j--) {
                            if (validPairs[j].vaultId === vaultId) {
                                validPairs.splice(j, 1);
                            }
                        }

                        // Reset count
                        validPairCount.set(vaultId, 0);

                        log.push({
                            step: i + 1,
                            candidate: candidate,
                            status: 'VAULT_REMOVED',
                            reason: `Vault ${vaultId} removed due to capacity exceeded`,
                            vaultRemoved: true
                        });
                    }
                    // V2: For non-capacity failures, just reject the individual pair
                }
            }

            return {
                validPairs: validPairs,
                removedPairs: removedPairs,
                removedVaults: Array.from(removedVaults),
                log: log
            };
        }

        // Apply valid pairs to attachments table
        function applyValidPairs(validPairs, attachments) {
            let newAttachments = [...attachments];

            // Separate pairs by protected/non-protected tags
            const protectedPairs = [];
            const nonProtectedPairs = [];

            for (const pair of validPairs) {
                const tag = getTagById(pair.tagId);
                if (tag && tag.isProtected) {
                    protectedPairs.push(pair);
                } else {
                    nonProtectedPairs.push(pair);
                }
            }

            // Handle non-protected pairs immediately (sync)
            for (const pair of nonProtectedPairs) {
                const { vaultId, tagId, action } = pair;

                if (action === 'add') {
                    // Add immediately as final
                    const exists = newAttachments.find(att =>
                        att.vaultId === vaultId && att.tagId === tagId
                    );

                    if (!exists) {
                        newAttachments.push({ vaultId, tagId, status: 'final', reqId: null });
                    }
                } else if (action === 'remove') {
                    // Remove immediately
                    newAttachments = newAttachments.filter(att =>
                        !(att.vaultId === vaultId && att.tagId === tagId)
                    );
                }
            }

            // Handle protected pairs with approval workflow (async)
            if (protectedPairs.length > 0) {
                const reqId = `REQ-${String(Date.now()).slice(-6)}`;

                // Extract the applied vaults and tags from protected pairs only
                const appliedVaults = [...new Set(protectedPairs.map(p => p.vaultId))];
                const appliedAddTags = [...new Set(protectedPairs.filter(p => p.action === 'add').map(p => p.tagId))];
                const appliedRemoveTags = [...new Set(protectedPairs.filter(p => p.action === 'remove').map(p => p.tagId))];

                // Store metadata for this request
                requestMetadata[reqId] = {
                    vaults: appliedVaults,
                    tagsToAdd: appliedAddTags,
                    tagsToRemove: appliedRemoveTags,
                    timestamp: new Date().toISOString()
                };

                for (const pair of protectedPairs) {
                    const { vaultId, tagId, action } = pair;

                    if (action === 'add') {
                        // Add as pending add
                        const exists = newAttachments.find(att =>
                            att.vaultId === vaultId && att.tagId === tagId
                        );

                        if (!exists) {
                            newAttachments.push({ vaultId, tagId, status: 'pending add', reqId });
                        }
                    } else if (action === 'remove') {
                        // Update existing row status to pending remove
                        const existingRow = newAttachments.find(att =>
                            att.vaultId === vaultId && att.tagId === tagId
                        );

                        if (existingRow) {
                            existingRow.status = 'pending remove';
                            existingRow.reqId = reqId;
                        }
                    }
                }
            }

            return newAttachments;
        }

        // Render functions
        function renderParsedInputs(vaults, addTags, removeTags) {
            const container = document.getElementById('parsedInputs');
            container.innerHTML = `
                <div><strong>Vaults:</strong> [${vaults.map(v => `"${v}"`).join(', ')}]</div>
                <div><strong>Tags To Add:</strong> [${addTags.map(t => `"${t}"`).join(', ')}]</div>
                <div><strong>Tags To Remove:</strong> [${removeTags.map(t => `"${t}"`).join(', ')}]</div>
            `;
        }

        function renderCandidatesTable(candidates) {
            const container = document.getElementById('candidatesTable');
            if (candidates.length === 0) {
                container.innerHTML = '<div class="empty-state">No candidates generated</div>';
                return;
            }

            const table = `
                <table>
                    <thead>
                        <tr>
                            <th>Vault ID</th>
                            <th>Tag ID</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${candidates.map(c => `
                            <tr>
                                <td>${c.vaultId}</td>
                                <td>${c.tagId}</td>
                                <td>${c.action}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;
            container.innerHTML = table;
        }

        function renderSanitizationLog(log) {
            const container = document.getElementById('sanitizationLog');
            if (log.length === 0) {
                container.innerHTML = '<div class="empty-state">Run sanitization to see processing log</div>';
                return;
            }

            const logEntries = log.map(entry => {
                if (entry.vaultRemoved) {
                    return `<div class="log-entry vault-removed">Step ${entry.step}: ${entry.reason}</div>`;
                } else {
                    const cssClass = entry.status === 'PASS' ? 'pass' : 'fail';
                    const candidateStr = `{${entry.candidate.vaultId}, ${entry.candidate.tagId}, ${entry.candidate.action}}`;
                    return `<div class="log-entry ${cssClass}">Step ${entry.step}: ${candidateStr} → ${entry.status} (${entry.reason})</div>`;
                }
            }).join('');

            container.innerHTML = logEntries;
        }

        function renderValidPairs(validPairs) {
            const container = document.getElementById('validPairsTable');
            if (validPairs.length === 0) {
                container.innerHTML = '<div class="empty-state">No valid pairs</div>';
                return;
            }

            const table = `
                <table>
                    <thead>
                        <tr>
                            <th>Vault ID</th>
                            <th>Tag ID</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${validPairs.map(p => `
                            <tr>
                                <td>${p.vaultId}</td>
                                <td>${p.tagId}</td>
                                <td>${p.action}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;
            container.innerHTML = table;
        }

        function renderRemovedVaults(removedVaults) {
            const container = document.getElementById('removedVaults');
            if (removedVaults.length === 0) {
                container.innerHTML = '<div class="empty-state">No vaults removed</div>';
                return;
            }

            container.innerHTML = `<div class="removed-vaults">Removed vaults: ${removedVaults.join(', ')}</div>`;
        }

        function renderAttachmentsTable() {
            const tbody = document.getElementById('attachmentsTableBody');
            tbody.innerHTML = currentAttachments.map((att, index) => {
                const reqIdCell = att.reqId ?
                    `<span class="req-link" onclick="showRequestModal('${att.reqId}')">${att.reqId}</span>` :
                    '<span style="color: #6c757d;">-</span>';

                // Determine row class based on status
                let rowClass = 'attachment-row';
                if (att.status === 'pending add') {
                    rowClass += ' pending-add';
                } else if (att.status === 'pending remove') {
                    rowClass += ' pending-remove';
                } else {
                    rowClass += ' final';
                }

                // Create status badge (clickable to cycle through states)
                const statusClass = att.status.replace(' ', '-');
                const statusBadge = `<span class="status-badge ${statusClass}" onclick="cycleStatus(${index})" style="cursor: pointer;" title="Click to change status">${att.status}</span>`;

                // Get tag info for tooltip
                const tag = getTagById(att.tagId);
                const tagTooltip = tag ? `${tag.label} (${tag.isProtected ? 'Protected' : 'Not Protected'})` : 'Tag not found';

                return `
                <tr class="${rowClass}">
                    <td><input type="text" value="${att.vaultId}" onchange="updateAttachment(${index}, 'vaultId', this.value)"></td>
                    <td><input type="text" value="${att.tagId}" onchange="updateAttachment(${index}, 'tagId', this.value)" title="${tagTooltip}" style="font-family: monospace;"></td>
                    <td>${statusBadge}</td>
                    <td>${reqIdCell}</td>
                    <td><button class="btn-secondary" style="font-size: 11px; padding: 2px 6px;" onclick="removeAttachment(${index})">Remove</button></td>
                </tr>
            `;
            }).join('');

            // Refresh edge cases when table changes - Commented out
            // generateEdgeCases();
        }

        function renderUpdatedAttachments(attachments) {
            const container = document.getElementById('updatedAttachmentsTable');
            if (attachments.length === 0) {
                container.innerHTML = '<div class="empty-state">No attachments</div>';
                return;
            }

            const table = `
                <table>
                    <thead>
                        <tr>
                            <th>Vault ID</th>
                            <th>Tag ID</th>
                            <th>Status</th>
                            <th>Req ID</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${attachments.map(att => {
                const reqIdCell = att.reqId ?
                    `<span class="req-link" onclick="showRequestModal('${att.reqId}')">${att.reqId}</span>` :
                    '<span style="color: #6c757d;">-</span>';
                return `
                            <tr>
                                <td>${att.vaultId}</td>
                                <td>${att.tagId}</td>
                                <td>${att.status}</td>
                                <td>${reqIdCell}</td>
                            </tr>
                        `;
            }).join('')}
                    </tbody>
                </table>
            `;
            container.innerHTML = table;
        }

        // Event handlers
        function generateCandidates() {
            const vaultsStr = document.getElementById('vaults').value;
            const addTagsStr = document.getElementById('tagsToAdd').value;
            const removeTagsStr = document.getElementById('tagsToRemove').value;

            const vaults = parseList(vaultsStr);
            const addTags = parseList(addTagsStr);
            const removeTags = parseList(removeTagsStr);

            console.log('Parsed inputs:', { vaults, addTags, removeTags });

            currentCandidates = buildCandidates(vaults, addTags, removeTags);

            console.log('Generated candidates:', currentCandidates);

            renderParsedInputs(vaults, addTags, removeTags);
            renderCandidatesTable(currentCandidates);

            // Clear later steps
            currentValidPairs = [];
            currentRemovedPairs = [];
            currentRemovedVaults = [];
            currentSanitizationLog = [];
            renderSanitizationLog([]);
            renderValidPairs([]);
            renderRemovedVaults([]);
        }

        function runSanitization() {
            if (currentCandidates.length === 0) {
                alert('Generate candidates first');
                return;
            }

            console.log('Starting sanitization with:', {
                candidates: currentCandidates,
                attachments: currentAttachments
            });

            const result = sanitizeCandidates(currentCandidates, currentAttachments);
            currentValidPairs = result.validPairs;
            currentRemovedPairs = result.removedPairs;
            currentRemovedVaults = result.removedVaults;
            currentSanitizationLog = result.log;

            console.log('Sanitization result:', result);

            renderSanitizationLog(currentSanitizationLog);
            renderValidPairs(currentValidPairs);
            renderRemovedVaults(currentRemovedVaults);
        }

        function applyToTable() {
            if (currentValidPairs.length === 0) {
                alert('Run sanitization first to get valid pairs');
                return;
            }

            // Update the main attachments table
            currentAttachments = applyValidPairs(currentValidPairs, currentAttachments);

            // Re-render both the editable table and the results view
            renderAttachmentsTable();
            renderUpdatedAttachments(currentAttachments);
        }

        function resetData() {
            // Reset inputs
            document.getElementById('vaults').value = 'v1,v2';
            document.getElementById('tagsToAdd').value = 't1,t2';
            document.getElementById('tagsToRemove').value = 't3';

            // Reset state
            initializeStarterData();
        }

        function clearResults() {
            currentCandidates = [];
            currentValidPairs = [];
            currentRemovedPairs = [];
            currentRemovedVaults = [];
            currentSanitizationLog = [];

            document.getElementById('parsedInputs').innerHTML = '<div class="empty-state">Click "Generate Candidates" to see parsed inputs</div>';
            document.getElementById('candidatesTable').innerHTML = '<div class="empty-state">No candidates generated yet</div>';
            document.getElementById('sanitizationLog').innerHTML = '<div class="empty-state">Run sanitization to see processing log</div>';
            document.getElementById('validPairsTable').innerHTML = '<div class="empty-state">No valid pairs yet</div>';
            document.getElementById('removedVaults').innerHTML = '<div class="empty-state">No vaults removed yet</div>';
            document.getElementById('updatedAttachmentsTable').innerHTML = '<div class="empty-state">Apply changes to see updated table</div>';
        }

        function updateAttachment(index, field, value) {
            if (index >= 0 && index < currentAttachments.length) {
                // Validate tag ID exists when changing tagId
                if (field === 'tagId') {
                    const tagExists = currentTags.some(tag => tag.id === value);
                    if (!tagExists && value.trim() !== '') {
                        alert(`Tag ID "${value}" does not exist. Please create the tag first or use an existing tag ID.`);
                        renderAttachmentsTable(); // Reset the input field
                        return;
                    }
                }

                currentAttachments[index][field] = value;

                // Re-render to update tooltips if tagId changed
                if (field === 'tagId') {
                    renderAttachmentsTable();
                }
            }
        }

        function cycleStatus(index) {
            if (index >= 0 && index < currentAttachments.length) {
                const statuses = ['final', 'pending add', 'pending remove'];
                const currentStatus = currentAttachments[index].status;
                const currentIndex = statuses.indexOf(currentStatus);
                const nextIndex = (currentIndex + 1) % statuses.length;

                currentAttachments[index].status = statuses[nextIndex];
                renderAttachmentsTable();
            }
        }

        function removeAttachment(index) {
            currentAttachments.splice(index, 1);
            renderAttachmentsTable();
        }

        function addAttachmentRow() {
            currentAttachments.push({ vaultId: '', tagId: '', status: 'final', reqId: null });
            renderAttachmentsTable();
        }

        // Modal functions
        function showRequestModal(reqId) {
            currentModalReqId = reqId;
            const requestPairs = currentAttachments.filter(att => att.reqId === reqId);
            const metadata = requestMetadata[reqId];

            document.getElementById('modalTitle').textContent = `Request ${reqId}`;

            const modalBody = document.getElementById('modalBody');
            if (requestPairs.length === 0) {
                modalBody.innerHTML = '<div class="empty-state">No pairs found for this request</div>';
            } else {
                let inputsSection = '';
                if (metadata) {
                    inputsSection = `
                        <div style="background-color: #f8f9fa; padding: 15px; margin-bottom: 20px; border-radius: 6px; border-left: 4px solid #007bff;">
                            <h4 style="margin: 0 0 10px 0; color: #333;">Original Inputs (Applied)</h4>
                            <div style="font-family: monospace; font-size: 13px; line-height: 1.4;">
                                <div><strong>Vaults:</strong> [${metadata.vaults.map(v => `"${v}"`).join(', ')}]</div>
                                ${metadata.tagsToAdd.length > 0 ? `<div><strong>Tags To Add:</strong> [${metadata.tagsToAdd.map(t => `"${t}"`).join(', ')}]</div>` : ''}
                                ${metadata.tagsToRemove.length > 0 ? `<div><strong>Tags To Remove:</strong> [${metadata.tagsToRemove.map(t => `"${t}"`).join(', ')}]</div>` : ''}
                            </div>
                            <div style="margin-top: 8px; font-size: 11px; color: #6c757d;">
                                Created: ${new Date(metadata.timestamp).toLocaleString()}
                            </div>
                        </div>
                    `;
                }

                const table = `
                    <h4 style="margin: 0 0 10px 0; color: #333;">Affected Pairs</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Vault ID</th>
                                <th>Tag ID</th>
                                <th>Action</th>
                                <th>Current Status</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${requestPairs.map(pair => `
                                <tr>
                                    <td>${pair.vaultId}</td>
                                    <td>${pair.tagId}</td>
                                    <td>${pair.status.replace('pending ', '')}</td>
                                    <td><span style="color: ${pair.status === 'pending add' ? '#28a745' : '#dc3545'};">${pair.status}</span></td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                `;
                modalBody.innerHTML = inputsSection + table;
            }

            document.getElementById('requestModal').style.display = 'block';
        }

        function closeRequestModal() {
            document.getElementById('requestModal').style.display = 'none';
            currentModalReqId = null;
        }

        function approveRequest() {
            if (!currentModalReqId) return;

            // Check if it's a tag request
            if (currentModalReqId.startsWith('TAG-')) {
                approveTagRequest();
                return;
            }

            // Store reqId before closing modal (which clears currentModalReqId)
            const reqId = currentModalReqId;

            // Close modal immediately
            closeRequestModal();

            // Find affected attachments and their actions before changes
            const affectedAttachments = currentAttachments
                .map((att, index) => ({ att, originalIndex: index }))
                .filter(item => item.att.reqId === reqId);

            // Process each attachment with this reqId
            currentAttachments = currentAttachments.filter(att => {
                if (att.reqId === reqId) {
                    if (att.status === 'pending remove') {
                        // Remove the attachment completely
                        return false;
                    }
                    // For pending add, convert to final
                    att.status = 'final';
                    att.reqId = null;
                }
                return true;
            });

            renderAttachmentsTable();
            renderUpdatedAttachments(currentAttachments);

            // Animate rows based on their specific changes
            setTimeout(() => {
                affectedAttachments.forEach((item, idx) => {
                    const { att } = item;

                    if (att.status === 'pending remove') {
                        // This row will be removed
                        const row = document.querySelector(`#attachmentsTableBody tr:nth-child(${item.originalIndex + 1})`);
                        if (row) {
                            row.classList.add('row-being-removed');
                            setTimeout(() => {
                                if (row.parentNode) {
                                    row.remove();
                                }
                            }, 1000);
                        }
                    } else if (att.status === 'pending add') {
                        // This row becomes final - find its new position
                        setTimeout(() => {
                            const newRows = document.querySelectorAll('#attachmentsTableBody tr');
                            const targetRow = Array.from(newRows).find(row => {
                                const vaultCell = row.cells[0].querySelector('input');
                                const tagCell = row.cells[1].querySelector('input');
                                return vaultCell && tagCell &&
                                    vaultCell.value === att.vaultId &&
                                    tagCell.value === att.tagId;
                            });
                            if (targetRow) {
                                targetRow.classList.add('row-becoming-final');
                                setTimeout(() => targetRow.classList.remove('row-becoming-final'), 1200);
                            }
                        }, 50);
                    }
                });
            }, 100);
        }

        function rejectRequest() {
            if (!currentModalReqId) return;

            // Check if it's a tag request
            if (currentModalReqId.startsWith('TAG-')) {
                rejectTagRequest();
                return;
            }

            // Store reqId before closing modal (which clears currentModalReqId)
            const reqId = currentModalReqId;

            // Close modal immediately
            closeRequestModal();

            // Find affected attachments and their actions before changes
            const affectedAttachments = currentAttachments
                .map((att, index) => ({ att, originalIndex: index }))
                .filter(item => item.att.reqId === reqId);

            console.log('Rejecting request:', reqId);
            console.log('Attachments before reject:', currentAttachments.filter(att => att.reqId === reqId));

            // Handle rejection based on the request type
            const newAttachments = [];

            for (const att of currentAttachments) {
                if (att.reqId === reqId) {
                    console.log('Processing attachment:', att);
                    if (att.status === 'pending add') {
                        // Remove pending add rows (they never existed)
                        console.log('Removing pending add:', att);
                        // Don't add to newAttachments (effectively removing it)
                    } else if (att.status === 'pending remove') {
                        // Revert pending remove back to final status
                        console.log('Reverting pending remove to final:', att);
                        newAttachments.push({
                            ...att,
                            status: 'final',
                            reqId: null
                        });
                    } else {
                        // Keep other statuses as-is
                        newAttachments.push(att);
                    }
                } else {
                    // Keep attachments not part of this request
                    newAttachments.push(att);
                }
            }

            currentAttachments = newAttachments;
            console.log('Attachments after reject:', currentAttachments);

            renderAttachmentsTable();
            renderUpdatedAttachments(currentAttachments);

            // Animate rows based on their specific changes
            setTimeout(() => {
                affectedAttachments.forEach((item) => {
                    const { att } = item;

                    if (att.status === 'pending add') {
                        // This row will be removed (it was never a real attachment)
                        const row = document.querySelector(`#attachmentsTableBody tr:nth-child(${item.originalIndex + 1})`);
                        if (row) {
                            row.classList.add('row-being-removed');
                            setTimeout(() => {
                                if (row.parentNode) {
                                    row.remove();
                                }
                            }, 1000);
                        }
                    } else if (att.status === 'pending remove') {
                        // This row gets reverted back to final - find its new position
                        setTimeout(() => {
                            const newRows = document.querySelectorAll('#attachmentsTableBody tr');
                            const targetRow = Array.from(newRows).find(row => {
                                const vaultCell = row.cells[0].querySelector('input');
                                const tagCell = row.cells[1].querySelector('input');
                                return vaultCell && tagCell &&
                                    vaultCell.value === att.vaultId &&
                                    tagCell.value === att.tagId;
                            });
                            if (targetRow) {
                                targetRow.classList.add('row-being-reverted');
                                setTimeout(() => targetRow.classList.remove('row-being-reverted'), 1000);
                            }
                        }, 50);
                    }
                });
            }, 100);
        }

        // Close modal when clicking outside
        window.onclick = function (event) {
            const modal = document.getElementById('requestModal');
            if (event.target === modal) {
                closeRequestModal();
            }
        }

        // Wizard Functions
        function showWizardStep(step) {
            currentWizardStep = step;

            // Update step indicators
            document.querySelectorAll('.wizard-step').forEach((el, index) => {
                const stepNum = index + 1;
                el.classList.remove('active', 'completed');

                if (stepNum === step) {
                    el.classList.add('active');
                } else if (stepNum < step) {
                    el.classList.add('completed');
                    el.querySelector('.step-indicator').textContent = '✓';
                } else {
                    el.querySelector('.step-indicator').textContent = stepNum;
                }
            });

            // Update navigation buttons
            document.getElementById('prevBtn').disabled = step === 1;
            const nextBtn = document.getElementById('nextBtn');

            if (step === maxSteps) {
                nextBtn.textContent = 'Apply Changes';
                nextBtn.className = 'btn-success';
            } else {
                nextBtn.textContent = 'Next';
                nextBtn.className = 'btn-primary';
            }

            // Load step content
            loadStepContent(step);
        }

        function loadStepContent(step) {
            const content = document.getElementById('wizardContent');

            switch (step) {
                case 1:
                    content.innerHTML = getStep1Content();
                    // Show initial input preview and validate
                    setTimeout(() => validateInputs(), 100);
                    break;
                case 2:
                    content.innerHTML = getStep2Content();
                    renderCandidatesInWizard();
                    break;
                case 3:
                    content.innerHTML = getStep3Content();
                    renderSanitizationInWizard();
                    break;
                case 4:
                    content.innerHTML = getStep4Content();
                    renderReviewInWizard();
                    break;
                case 5:
                    content.innerHTML = getStep5Content();
                    break;
            }
        }

        function getStep1Content() {
            return `
                <h3>Configure Inputs</h3>
                
                <div class="input-group">
                    <label for="vaults">Vaults:</label>
                    <textarea id="vaults" rows="3" placeholder="v1, v2, v3" oninput="validateInputs()">v1,v2</textarea>
                </div>
                
                <div class="input-group">
                    <label for="tagsToAdd">Tags To Add (max 3):</label>
                    <textarea id="tagsToAdd" rows="3" placeholder="t1, t2, t3" oninput="validateInputs()">t1,t2</textarea>
                    <div id="tagsToAddError" class="validation-error" style="display: none;"></div>
                </div>
                
                <div class="input-group">
                    <label for="tagsToRemove">Tags To Remove (max 3):</label>
                    <textarea id="tagsToRemove" rows="3" placeholder="t3, t4" oninput="validateInputs()">t3</textarea>
                    <div id="tagsToRemoveError" class="validation-error" style="display: none;"></div>
                </div>
                
                <div id="conflictError" class="validation-error" style="display: none; margin-top: 10px;"></div>
                
                <div id="validationErrorButton" style="display: none; margin-top: 15px; text-align: center;">
                    <button class="btn-secondary" onclick="showCurrentValidationErrors()" style="font-size: 12px; padding: 6px 12px; background: #fff3cd; border: 1px solid #ffeaa7; color: #856404;">
                        ⚠️ View API Response for Current Errors
                    </button>
                </div>
                
                <div id="parsedInputsPreview" class="arrays-display" style="margin-top: 20px;">
                </div>
            `;
        }

        function getStep2Content() {
            return `
                <h3>Generated Candidates</h3>
                <p>Review the candidate pairs generated from your inputs.</p>
                <div id="candidatesWizardContent">
                    <div class="empty-state">Generating candidates...</div>
                </div>
            `;
        }

        function getStep3Content() {
            return `
                <h3>Sanitization Process</h3>
                <p>Watch the sequential validation of each candidate pair.</p>
                <div id="sanitizationWizardContent">
                    <div class="empty-state">Running sanitization...</div>
                </div>
            `;
        }

        function getStep4Content() {
            return `
                <h3>Review Results</h3>
                <p>Review the final valid pairs and any removed vaults before applying changes.</p>
                <div id="reviewWizardContent">
                    <div class="empty-state">Preparing results...</div>
                </div>
            `;
        }

        function getStep5Content() {
            return `
                <h3>Changes Applied</h3>
                <p>Your changes have been applied to the attachments table. Protected tags require approval, while non-protected tags are applied immediately.</p>
                <div id="applyWizardContent">
                    <div class="empty-state">Applying changes...</div>
                </div>
            `;
        }

        function nextStep() {
            if (currentWizardStep < maxSteps) {
                // Check validation for step 1
                if (currentWizardStep === 1 && !validateInputs()) {
                    return; // Don't proceed if validation fails
                }

                // Process current step before moving to next
                processCurrentStep();
                showWizardStep(currentWizardStep + 1);
            } else {
                // Apply changes on final step
                applyChangesFromWizard();
            }
        }

        function previousStep() {
            if (currentWizardStep > 1) {
                showWizardStep(currentWizardStep - 1);
            }
        }

        function resetWizard() {
            // Reset all data
            currentCandidates = [];
            currentValidPairs = [];
            currentRemovedPairs = [];
            currentRemovedVaults = [];
            currentSanitizationLog = [];

            // Go back to step 1
            showWizardStep(1);
        }

        function processCurrentStep() {
            switch (currentWizardStep) {
                case 1:
                    generateCandidatesInWizard();
                    break;
                case 2:
                    runSanitizationInWizard();
                    break;
                case 3:
                    // Sanitization already complete, just move to review
                    break;
                case 4:
                    // Review complete, prepare for apply
                    break;
            }
        }

        function generateCandidatesInWizard() {
            const vaultsStr = document.getElementById('vaults').value;
            const addTagsStr = document.getElementById('tagsToAdd').value;
            const removeTagsStr = document.getElementById('tagsToRemove').value;

            const vaults = parseList(vaultsStr);
            const addTags = parseList(addTagsStr);
            const removeTags = parseList(removeTagsStr);

            currentCandidates = buildCandidates(vaults, addTags, removeTags);

            // Update parsed inputs preview in step 1
            const preview = document.getElementById('parsedInputsPreview');
            if (preview) {
                preview.innerHTML = `
                    <div><strong>Vaults:</strong> [${vaults.map(v => `"${v}"`).join(', ')}]</div>
                    <div><strong>Tags To Add:</strong> [${addTags.map(t => `"${t}"`).join(', ')}]</div>
                    <div><strong>Tags To Remove:</strong> [${removeTags.map(t => `"${t}"`).join(', ')}]</div>
                `;
            }
        }

        function runSanitizationInWizard() {
            const result = sanitizeCandidates(currentCandidates, currentAttachments);
            currentValidPairs = result.validPairs;
            currentRemovedPairs = result.removedPairs;
            currentRemovedVaults = result.removedVaults;
            currentSanitizationLog = result.log;
        }

        function applyChangesFromWizard() {
            const wizardContent = document.getElementById('wizardContent');
            const content = document.getElementById('applyWizardContent');

            // Start applying animation
            wizardContent.classList.add('wizard-applying');
            content.innerHTML = `
                <div style="background-color: #e3f2fd; border: 1px solid #bbdefb; border-radius: 6px; padding: 15px; margin-bottom: 20px;">
                    <h4 style="color: #1565c0; margin: 0 0 10px 0;">
                        <span class="applying-spinner"></span>Applying Changes...
                    </h4>
                    <p style="color: #1565c0; margin: 0;">Processing your request and updating the attachments table.</p>
                </div>
            `;

            // Simulate processing time and then apply changes
            setTimeout(() => {
                if (currentValidPairs.length > 0) {
                    currentAttachments = applyValidPairs(currentValidPairs, currentAttachments);
                    renderAttachmentsTable();

                    // Add success animation to table area
                    const tableArea = document.querySelector('.table-area');
                    tableArea.classList.add('success-bounce');

                    // Show completion message with protected/non-protected breakdown
                    const reqIds = [...new Set(currentAttachments.filter(att => att.reqId).map(att => att.reqId))];
                    const latestReqId = reqIds[reqIds.length - 1];

                    // Separate pairs by protection status
                    const protectedPairs = currentValidPairs.filter(pair => {
                        const tag = getTagById(pair.tagId);
                        return tag && tag.isProtected;
                    });
                    const nonProtectedPairs = currentValidPairs.filter(pair => {
                        const tag = getTagById(pair.tagId);
                        return !tag || !tag.isProtected;
                    });

                    let protectedSection = '';
                    if (protectedPairs.length > 0) {
                        protectedSection = `
                            <div style="background-color: #fff3e0; border: 1px solid #ffcc02; border-radius: 6px; padding: 15px; margin-bottom: 15px;">
                                <h4 style="color: #ef6c00; margin: 0 0 10px 0;">🔒 Protected Tag Operations (Require Approval)</h4>
                                <p style="color: #ef6c00; margin: 0;">
                                    ${protectedPairs.length} operation(s) with protected tags created request <strong>${latestReqId}</strong>.
                                </p>
                                <ul style="margin: 10px 0;">
                                    ${protectedPairs.map(pair => `
                                        <li>${pair.action} ${pair.tagId} ${pair.action === 'add' ? 'to' : 'from'} vault ${pair.vaultId}</li>
                                    `).join('')}
                                </ul>
                            </div>
                        `;
                    }

                    let nonProtectedSection = '';
                    if (nonProtectedPairs.length > 0) {
                        nonProtectedSection = `
                            <div style="background-color: #d4edda; border: 1px solid #c3e6cb; border-radius: 6px; padding: 15px; margin-bottom: 15px;">
                                <h4 style="color: #155724; margin: 0 0 10px 0;">⚡ Non-Protected Tag Operations (Applied Immediately)</h4>
                                <p style="color: #155724; margin: 0;">
                                    ${nonProtectedPairs.length} operation(s) with non-protected tags applied directly.
                                </p>
                                <ul style="margin: 10px 0;">
                                    ${nonProtectedPairs.map(pair => `
                                        <li>${pair.action} ${pair.tagId} ${pair.action === 'add' ? 'to' : 'from'} vault ${pair.vaultId}</li>
                                    `).join('')}
                                </ul>
                            </div>
                        `;
                    }

                    let removedPairsSection = '';
                    if (currentRemovedPairs.length > 0) {
                        removedPairsSection = `
                            <div style="background-color: #f8d7da; border: 1px solid #f5c6cb; border-radius: 6px; padding: 15px; margin-bottom: 15px;">
                                <h4 style="color: #721c24; margin: 0 0 10px 0;">❌ Removed Pairs</h4>
                                <p style="color: #721c24; margin: 0;">
                                    ${currentRemovedPairs.length} pair(s) were rejected during processing.
                                </p>
                                <ul style="margin: 10px 0;">
                                    ${currentRemovedPairs.map(pair => `
                                        <li>${pair.action} ${pair.tagId} ${pair.action === 'add' ? 'to' : 'from'} vault ${pair.vaultId} - ${pair.reason}</li>
                                    `).join('')}
                                </ul>
                            </div>
                        `;
                    }

                    let removedVaultsSection = '';
                    if (currentRemovedVaults.length > 0) {
                        removedVaultsSection = `
                            <div style="background-color: #fff3cd; border: 1px solid #ffeaa7; border-radius: 6px; padding: 15px; margin-bottom: 15px;">
                                <h4 style="color: #856404; margin: 0 0 10px 0;">⚠️ Removed Vaults</h4>
                                <p style="color: #856404; margin: 0;">
                                    ${currentRemovedVaults.length} vault(s) were removed due to capacity constraints.
                                </p>
                                <ul style="margin: 10px 0;">
                                    ${currentRemovedVaults.map(vaultId => `
                                        <li>Vault ${vaultId} - capacity exceeded (max 3 attachments)</li>
                                    `).join('')}
                                </ul>
                            </div>
                        `;
                    }

                    let apiResponseButton = `
                        <div style="text-align: center; margin-top: 20px;">
                            <button 
                                onclick="showApiResponseFromWizard()" 
                                style="background-color: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; font-size: 14px;"
                                onmouseover="this.style.backgroundColor='#0056b3'" 
                                onmouseout="this.style.backgroundColor='#007bff'"
                            >
                                View API Response
                            </button>
                        </div>
                    `;

                    content.innerHTML = protectedSection + nonProtectedSection + removedPairsSection + removedVaultsSection + apiResponseButton;

                    // Clean up animations
                    setTimeout(() => {
                        wizardContent.classList.remove('wizard-applying');
                        tableArea.classList.remove('success-bounce');
                    }, 1000);
                } else {
                    content.innerHTML = `
                        <div style="background-color: #fff3cd; border: 1px solid #ffeaa7; border-radius: 6px; padding: 15px;">
                            <h4 style="color: #856404; margin: 0 0 10px 0;">⚠️ No Changes Applied</h4>
                            <p style="color: #856404; margin: 0;">No valid pairs were found. All candidates were filtered out during sanitization.</p>
                        </div>
                    `;
                    wizardContent.classList.remove('wizard-applying');
                }
            }, 1500); // 1.5 second delay to show the applying animation
        }

        function renderCandidatesInWizard() {
            const container = document.getElementById('candidatesWizardContent');
            if (currentCandidates.length === 0) {
                container.innerHTML = '<div class="empty-state">No candidates generated</div>';
                return;
            }

            const table = `
                <table>
                    <thead>
                        <tr>
                            <th>Vault ID</th>
                            <th>Tag ID</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${currentCandidates.map(c => `
                            <tr>
                                <td>${c.vaultId}</td>
                                <td>${c.tagId}</td>
                                <td>${c.action}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;
            container.innerHTML = table;
        }

        function renderSanitizationInWizard() {
            const container = document.getElementById('sanitizationWizardContent');
            if (currentSanitizationLog.length === 0) {
                container.innerHTML = '<div class="empty-state">Running sanitization...</div>';
                return;
            }

            const logEntries = currentSanitizationLog.map(entry => {
                if (entry.vaultRemoved) {
                    return `<div class="log-entry vault-removed">Step ${entry.step}: ${entry.reason}</div>`;
                } else {
                    const cssClass = entry.status === 'PASS' ? 'pass' : 'fail';
                    const candidateStr = `{${entry.candidate.vaultId}, ${entry.candidate.tagId}, ${entry.candidate.action}}`;
                    return `<div class="log-entry ${cssClass}">Step ${entry.step}: ${candidateStr} → ${entry.status} (${entry.reason})</div>`;
                }
            }).join('');

            container.innerHTML = `<div class="log-container">${logEntries}</div>`;
        }

        function renderReviewInWizard() {
            const container = document.getElementById('reviewWizardContent');

            let validPairsHtml = '';
            if (currentValidPairs.length > 0) {
                validPairsHtml = `
                    <h4>Valid Pairs (${currentValidPairs.length})</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Vault ID</th>
                                <th>Tag ID</th>
                                <th>Action</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${currentValidPairs.map(p => `
                                <tr>
                                    <td>${p.vaultId}</td>
                                    <td>${p.tagId}</td>
                                    <td>${p.action}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                `;
            } else {
                validPairsHtml = '<h4>Valid Pairs</h4><div class="empty-state">No valid pairs</div>';
            }
            
            let removedPairsHtml = '';
            if (currentRemovedPairs.length > 0) {
                removedPairsHtml = `
                    <h4 style="margin-top: 20px;">Removed Pairs (${currentRemovedPairs.length})</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Vault ID</th>
                                <th>Tag ID</th>
                                <th>Action</th>
                                <th>Reason</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${currentRemovedPairs.map(p => `
                                <tr class="removed-pair">
                                    <td>${p.vaultId}</td>
                                    <td>${p.tagId}</td>
                                    <td>${p.action}</td>
                                    <td>${p.reason}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                `;
            }

            let removedVaultsHtml = '';
            if (currentRemovedVaults.length > 0) {
                removedVaultsHtml = `<div class="removed-vaults" style="margin-top: 20px;">Removed vaults: ${currentRemovedVaults.join(', ')}</div>`;
            }

            container.innerHTML = validPairsHtml + removedPairsHtml + removedVaultsHtml;
        }

        // Global validation state for API response
        let currentValidationErrors = [];

        function validateInputs() {
            const vaultsEl = document.getElementById('vaults');
            const addTagsEl = document.getElementById('tagsToAdd');
            const removeTagsEl = document.getElementById('tagsToRemove');

            if (!vaultsEl || !addTagsEl || !removeTagsEl) return true;

            // Reset validation errors
            currentValidationErrors = [];


            const vaults = parseList(vaultsEl.value);
            const addTags = parseList(addTagsEl.value);
            const removeTags = parseList(removeTagsEl.value);

            let isValid = true;

            // Clear previous validation styles
            vaultsEl.classList.remove('invalid');
            addTagsEl.classList.remove('invalid');
            removeTagsEl.classList.remove('invalid');

            // Hide all error messages
            const addError = document.getElementById('tagsToAddError');
            const removeError = document.getElementById('tagsToRemoveError');
            const conflictError = document.getElementById('conflictError');

            if (addError) addError.style.display = 'none';
            if (removeError) removeError.style.display = 'none';
            if (conflictError) conflictError.style.display = 'none';

            // Validate tag count limits
            if (addTags.length > 3) {
                addTagsEl.classList.add('invalid');
                if (addError) {
                    addError.textContent = `Too many tags (${addTags.length}/3). Maximum 3 tags allowed.`;
                    addError.style.display = 'block';
                }
                currentValidationErrors.push({
                    field: 'tagsToAdd',
                    error: 'array_too_large',
                    message: `Maximum 3 tags allowed, got ${addTags.length}`,
                    value: addTags
                });
                isValid = false;
            }

            if (removeTags.length > 3) {
                removeTagsEl.classList.add('invalid');
                if (removeError) {
                    removeError.textContent = `Too many tags (${removeTags.length}/3). Maximum 3 tags allowed.`;
                    removeError.style.display = 'block';
                }
                currentValidationErrors.push({
                    field: 'tagsToRemove',
                    error: 'array_too_large',
                    message: `Maximum 3 tags allowed, got ${removeTags.length}`,
                    value: removeTags
                });
                isValid = false;
            }

            // Validate vault IDs (must start with 'v')
            const invalidVaults = vaults.filter(vaultId => !vaultId.startsWith('v'));
            if (invalidVaults.length > 0) {
                vaultsEl.classList.add('invalid');
                if (conflictError) {
                    conflictError.textContent = `Invalid vault IDs: [${invalidVaults.join(', ')}]. Vault IDs must start with 'v'.`;
                    conflictError.style.display = 'block';
                }
                currentValidationErrors.push({
                    field: 'vaults',
                    error: 'invalid_vault_ids',
                    message: `Vault IDs must start with 'v': ${invalidVaults.join(', ')}`,
                    invalid_vaults: invalidVaults
                });
                isValid = false;
            }

            // Validate no tag appears in both arrays
            const conflicts = addTags.filter(tag => removeTags.includes(tag));
            if (conflicts.length > 0) {
                addTagsEl.classList.add('invalid');
                removeTagsEl.classList.add('invalid');
                if (conflictError) {
                    conflictError.textContent = `Tags appear in both add and remove: [${conflicts.join(', ')}]. A tag cannot be both added and removed.`;
                    conflictError.style.display = 'block';
                }
                currentValidationErrors.push({
                    field: 'tags',
                    error: 'conflicting_operations',
                    message: `Tags cannot be in both add and remove: ${conflicts.join(', ')}`,
                    conflicting_tags: conflicts
                });
                isValid = false;
            }

            // Validate all tags exist in the tags table and are not being edited
            const allInputTags = [...addTags, ...removeTags];
            const invalidTags = allInputTags.filter(tagId => !currentTags.some(tag => tag.id === tagId));
            const tagsBeingEdited = allInputTags.filter(tagId => {
                const tag = currentTags.find(t => t.id === tagId);
                return tag && tag.status === 'pendingEdit';
            });

            const allInvalidTags = [...invalidTags, ...tagsBeingEdited];
            if (invalidTags.length > 0) {
                addTagsEl.classList.add('invalid');
                removeTagsEl.classList.add('invalid');
                if (conflictError) {
                    conflictError.textContent = `Invalid tag IDs: [${invalidTags.join(', ')}]. These tags do not exist. Create them in the Tags table first.`;
                    conflictError.style.display = 'block';
                }
                currentValidationErrors.push({
                    field: allInputTags.some(t => addTags.includes(t)) ? 'tagsToAdd' : 'tagsToRemove',
                    error: 'invalid_tags',
                    message: `Tags do not exist: ${invalidTags.join(', ')}`,
                    invalid_tags: invalidTags
                });
                isValid = false;
            }

            if (tagsBeingEdited.length > 0) {
                addTagsEl.classList.add('invalid');
                removeTagsEl.classList.add('invalid');
                if (conflictError) {
                    const errorMsg = `Tags being edited: [${tagsBeingEdited.join(', ')}]. Complete pending tag operations first.`;
                    conflictError.textContent = conflictError.style.display === 'block' ?
                        conflictError.textContent + ' ' + errorMsg : errorMsg;
                    conflictError.style.display = 'block';
                }
                currentValidationErrors.push({
                    field: allInputTags.some(t => addTags.includes(t)) ? 'tagsToAdd' : 'tagsToRemove',
                    error: 'tags_being_modified',
                    message: `Tags currently being edited: ${tagsBeingEdited.join(', ')}`,
                    unavailable_tags: tagsBeingEdited
                });
                isValid = false;
            }

            // Show/hide validation error button
            const errorButton = document.getElementById('validationErrorButton');
            if (errorButton) {
                if (currentValidationErrors.length > 0) {
                    errorButton.style.display = 'block';
                } else {
                    errorButton.style.display = 'none';
                }
            }

            // Update preview
            updateInputPreview();

            // Update navigation button state
            updateNextButtonState(isValid);

            return isValid;
        }

        // Function to show current validation errors in a modal
        function showCurrentValidationErrors() {
            if (currentValidationErrors.length === 0) {
                alert('No validation errors currently.');
                return;
            }

            const errorResponse = {
                error: 'validation_failed',
                message: currentValidationErrors.length === 1 ? 'Input validation failed' : 'Multiple validation errors',
                details: currentValidationErrors
            };

            // Create a temporary modal to show the current errors
            const modalHtml = `
                <div id="currentErrorsModal" class="modal" style="display: block;">
                    <div class="modal-content" style="max-width: 600px;">
                        <div class="modal-header">
                            <h3 class="modal-title">🚨 Current Validation Errors</h3>
                            <button class="close" onclick="closeCurrentErrorsModal()">&times;</button>
                        </div>
                        <div style="padding: 20px;">
                            <p style="margin-bottom: 15px; color: #856404; font-size: 13px;">API would return 400 Bad Request with this response:</p>
                            <pre class="json-response">${JSON.stringify(errorResponse, null, 2)}</pre>
                        </div>
                        <div class="modal-buttons">
                            <button class="btn-secondary" onclick="closeCurrentErrorsModal()">Close</button>
                        </div>
                    </div>
                </div>
            `;

            // Add modal to body
            document.body.insertAdjacentHTML('beforeend', modalHtml);
        }

        function closeCurrentErrorsModal() {
            const modal = document.getElementById('currentErrorsModal');
            if (modal) {
                modal.remove();
            }
        }

        function updateNextButtonState(isValid) {
            const nextBtn = document.getElementById('nextBtn');
            if (nextBtn && currentWizardStep === 1) {
                nextBtn.disabled = !isValid;
                if (!isValid) {
                    nextBtn.classList.add('btn-secondary');
                    nextBtn.classList.remove('btn-primary');
                } else {
                    nextBtn.classList.add('btn-primary');
                    nextBtn.classList.remove('btn-secondary');
                }
            }
        }

        function updateInputPreview() {
            const vaultsEl = document.getElementById('vaults');
            const addTagsEl = document.getElementById('tagsToAdd');
            const removeTagsEl = document.getElementById('tagsToRemove');
            const previewEl = document.getElementById('parsedInputsPreview');

            if (!vaultsEl || !addTagsEl || !removeTagsEl || !previewEl) return;

            const vaults = parseList(vaultsEl.value);
            const addTags = parseList(addTagsEl.value);
            const removeTags = parseList(removeTagsEl.value);

            previewEl.innerHTML = `
                <div><strong>Vaults:</strong> [${vaults.map(v => `"${v}"`).join(', ')}]</div>
                <div><strong>Tags To Add:</strong> [${addTags.map(t => `"${t}"`).join(', ')}]</div>
                <div><strong>Tags To Remove:</strong> [${removeTags.map(t => `"${t}"`).join(', ')}]</div>
            `;
        }

        resetWizard()

        // Global variable to store the current API response
        let currentApiResponse = null;

        // Function to generate API response based on current operations
        function generateApiResponse() {
            const appliedOperations = [];
            const pendingOperations = [];
            const rejectedOperations = [];
            
            // Process valid pairs based on protection status
            if (currentValidPairs && currentValidPairs.length > 0) {
                currentValidPairs.forEach(pair => {
                    const tag = getTagById(pair.tagId);
                    if (tag && tag.isProtected) {
                        // Protected tags go to pending with request ID
                        const reqId = `REQ-${String(Date.now()).slice(-6)}`;
                        pendingOperations.push({
                            vault: pair.vaultId,
                            tag: pair.tagId,
                            action: pair.action,
                            status: 'pending',
                            request_id: reqId
                        });
                    } else {
                        // Non-protected tags are applied immediately
                        appliedOperations.push({
                            vault: pair.vaultId,
                            tag: pair.tagId,
                            action: pair.action,
                            status: 'final'
                        });
                    }
                });
            }

            // Process removed pairs as rejected operations
            if (currentRemovedPairs && currentRemovedPairs.length > 0) {
                currentRemovedPairs.forEach(pair => {
                    rejectedOperations.push({
                        vault: pair.vaultId,
                        tag: pair.tagId,
                        action: pair.action,
                        status: 'rejected',
                        reason: pair.reason
                    });
                });
            }

            // Process removed vaults
            const removedVaults = [];
            if (currentRemovedVaults && currentRemovedVaults.length > 0) {
                currentRemovedVaults.forEach(vaultId => {
                    removedVaults.push({
                        vault: vaultId,
                        reason: 'capacity_exceeded',
                        max_attachments: 3
                    });
                });
            }

            // Determine status and message based on all operations
            let status, message;
            const totalOperations = appliedOperations.length + pendingOperations.length + rejectedOperations.length;
            
            if (totalOperations === 0) {
                status = 'no_operations_requested';
                message = 'No operations were requested';
            } else if (rejectedOperations.length === totalOperations) {
                status = 'all_operations_rejected';
                message = 'All operations were rejected';
            } else if (appliedOperations.length > 0 && pendingOperations.length > 0 && rejectedOperations.length > 0) {
                status = 'mixed_results';
                message = `${appliedOperations.length} applied, ${pendingOperations.length} pending approval, ${rejectedOperations.length} rejected`;
            } else if (appliedOperations.length > 0 && pendingOperations.length > 0) {
                status = 'partial_success_mixed_protection';
                message = `${appliedOperations.length} applied immediately, ${pendingOperations.length} require approval`;
            } else if (appliedOperations.length > 0 && rejectedOperations.length > 0) {
                status = 'partial_success_with_rejections';
                message = `${appliedOperations.length} applied, ${rejectedOperations.length} rejected`;
            } else if (pendingOperations.length > 0 && rejectedOperations.length > 0) {
                status = 'pending_with_rejections';
                message = `${pendingOperations.length} pending approval, ${rejectedOperations.length} rejected`;
            } else if (pendingOperations.length > 0) {
                status = 'all_pending_approval';
                message = 'All valid operations require approval (protected tags)';
            } else if (appliedOperations.length > 0) {
                status = 'success';
                message = 'All valid operations applied successfully';
            } else if (rejectedOperations.length > 0) {
                status = 'all_operations_rejected';
                message = 'All operations were rejected';
            }

            const response = {
                status: status,
                message: message,
                applied_operations: appliedOperations,
                pending_operations: pendingOperations,
                rejected_operations: rejectedOperations,
                removed_vaults: removedVaults,
                summary: {
                    total_requested: totalOperations,
                    applied_count: appliedOperations.length,
                    pending_count: pendingOperations.length,
                    rejected_count: rejectedOperations.length,
                    removed_vault_count: removedVaults.length
                }
            };

            return response;
        }

        // Function to show current API response
        function showCurrentApiResponse() {
            if (!currentApiResponse) {
                currentApiResponse = generateApiResponse();
            }
            
            const originalApiCall = generateOriginalApiCall();

            const modalHtml = `
                <div id="currentApiResponseModal" class="modal" style="display: block;">
                    <div class="modal-content" style="max-width: 800px;">
                        <div class="modal-header">
                            <h3 class="modal-title">🚀 API Request & Response</h3>
                            <button class="close" onclick="closeCurrentApiResponseModal()">&times;</button>
                        </div>
                        <div style="padding: 20px;">
                            <div style="margin-bottom: 25px;">
                                <h4 style="color: #0066cc; margin-bottom: 10px;">📤 Original API Request</h4>
                                <p style="margin-bottom: 10px; color: #6c757d; font-size: 13px;">The API call that would be made based on your inputs:</p>
                                <pre class="json-response" style="background-color: #f8f9fa; border-left: 4px solid #0066cc;">${originalApiCall.method} ${originalApiCall.url}

${JSON.stringify({
    headers: originalApiCall.headers,
    body: originalApiCall.body
}, null, 2)}</pre>
                            </div>
                            
                            <div>
                                <h4 style="color: #28a745; margin-bottom: 10px;">📥 API Response</h4>
                                <p style="margin-bottom: 10px; color: #6c757d; font-size: 13px;">The response returned by the API after processing:</p>
                                <pre class="json-response" style="background-color: #f8f9fa; border-left: 4px solid #28a745;">HTTP 200 OK

${JSON.stringify(currentApiResponse, null, 2)}</pre>
                            </div>
                        </div>
                        <div class="modal-buttons">
                            <button class="btn-secondary" onclick="closeCurrentApiResponseModal()">Close</button>
                        </div>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', modalHtml);
        }

        function closeCurrentApiResponseModal() {
            const modal = document.getElementById('currentApiResponseModal');
            if (modal) {
                modal.remove();
            }
        }

        // Function to add API response button to any completion content
        function addApiResponseButton(containerId) {
            const container = document.getElementById(containerId);
            if (container && !container.querySelector('.api-response-button')) {
                const buttonHtml = `
                    <div class="api-response-button" style="margin-top: 20px; text-align: center; padding-top: 15px; border-top: 1px solid #dee2e6;">
                        <button class="btn-secondary" onclick="showCurrentApiResponse()" style="background: #e3f2fd; border: 1px solid #90caf9; color: #1565c0; padding: 8px 16px; font-size: 13px;">
                            🚀 View API Response
                        </button>
                        <p style="margin: 8px 0 0 0; font-size: 11px; color: #6c757d;">See the exact API response for these operations</p>
                    </div>
                `;
                container.insertAdjacentHTML('beforeend', buttonHtml);
            }
        }

        // Function to ensure API response is reset when operations change
        function resetApiResponse() {
            currentApiResponse = null;
        }

        // Function to show API response from wizard context
        function showApiResponseFromWizard() {
            // Reset and regenerate the API response based on current operations
            currentApiResponse = null;
            showCurrentApiResponse();
        }

        // Function to generate the original API call based on current wizard inputs
        function generateOriginalApiCall() {
            // Extract the original inputs from candidates
            const vaults = new Set();
            const addTags = new Set();
            const removeTags = new Set();
            
            // Get the original input data from candidates
            if (currentCandidates && currentCandidates.length > 0) {
                currentCandidates.forEach(candidate => {
                    vaults.add(candidate.vaultId);
                    if (candidate.action === 'add') {
                        addTags.add(candidate.tagId);
                    } else if (candidate.action === 'remove') {
                        removeTags.add(candidate.tagId);
                    }
                });
            }
            
            // Create the API call object with the 3 arrays
            const apiCall = {
                method: 'POST',
                url: '/api/vault-tags/batch',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': 'Bearer <your-api-token>'
                },
                body: {
                    vaults: Array.from(vaults),
                    tags_to_add: Array.from(addTags),
                    tags_to_remove: Array.from(removeTags)
                }
            };
            
            return apiCall;
        }

        // Helper function to get tag by ID
        function getTagById(tagId) {
            return currentTags.find(tag => tag.id === tagId);
        }

        // Behavior Modal Functions
        function showBehaviorModal() {
            const modal = document.getElementById('behaviorModal');
            modal.style.display = 'block';
        }

        function closeBehaviorModal() {
            const modal = document.getElementById('behaviorModal');
            modal.style.display = 'none';
        }

        // Validation Errors Modal Functions
        function showValidationErrorsModal() {
            const modal = document.getElementById('validationErrorsModal');
            modal.style.display = 'block';
        }

        function closeValidationErrorsModal() {
            const modal = document.getElementById('validationErrorsModal');
            modal.style.display = 'none';
        }

        // Sanitization Results Modal Functions
        function showSanitizationResultsModal() {
            const modal = document.getElementById('sanitizationResultsModal');
            modal.style.display = 'block';
        }

        function closeSanitizationResultsModal() {
            const modal = document.getElementById('sanitizationResultsModal');
            modal.style.display = 'none';
        }

        // Protection Workflows Modal Functions
        function showProtectionWorkflowsModal() {
            const modal = document.getElementById('protectionWorkflowsModal');
            modal.style.display = 'block';
        }

        function closeProtectionWorkflowsModal() {
            const modal = document.getElementById('protectionWorkflowsModal');
            modal.style.display = 'none';
        }

        // Success & Failure Modal Functions
        function showSuccessFailureModal() {
            const modal = document.getElementById('successFailureModal');
            modal.style.display = 'block';
        }

        function closeSuccessFailureModal() {
            const modal = document.getElementById('successFailureModal');
            modal.style.display = 'none';
        }

        // Sanitization Results Modal Functions
        function showSanitizationResultsModal() {
            const modal = document.getElementById('sanitizationResultsModal');
            modal.style.display = 'block';
        }

        function closeSanitizationResultsModal() {
            const modal = document.getElementById('sanitizationResultsModal');
            modal.style.display = 'none';
        }

        // Protection Workflows Modal Functions
        function showProtectionWorkflowsModal() {
            const modal = document.getElementById('protectionWorkflowsModal');
            modal.style.display = 'block';
        }

        function closeProtectionWorkflowsModal() {
            const modal = document.getElementById('protectionWorkflowsModal');
            modal.style.display = 'none';
        }

        // Success & Failure Modal Functions
        function showSuccessFailureModal() {
            const modal = document.getElementById('successFailureModal');
            modal.style.display = 'block';
        }

        function closeSuccessFailureModal() {
            const modal = document.getElementById('successFailureModal');
            modal.style.display = 'none';
        }

        // Close modals when clicking outside of them
        window.addEventListener('click', function (event) {
            const behaviorModal = document.getElementById('behaviorModal');
            const validationErrorsModal = document.getElementById('validationErrorsModal');
            const sanitizationResultsModal = document.getElementById('sanitizationResultsModal');
            const protectionWorkflowsModal = document.getElementById('protectionWorkflowsModal');
            const successFailureModal = document.getElementById('successFailureModal');

            if (event.target === behaviorModal) {
                closeBehaviorModal();
            }
            if (event.target === validationErrorsModal) {
                closeValidationErrorsModal();
            }
            if (event.target === sanitizationResultsModal) {
                closeSanitizationResultsModal();
            }
            if (event.target === protectionWorkflowsModal) {
                closeProtectionWorkflowsModal();
            }
            if (event.target === successFailureModal) {
                closeSuccessFailureModal();
            }
        });

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function () {
            initializeStarterData();
            showWizardStep(1);
        });
    </script>
</body>

</html>