<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tagging Workflow Simulator V2 - Selective Vault Removal</title>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            font-size: 14px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 500px 1fr;
            gap: 20px;
        }

        .wizard-area {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .table-area {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        h1 {
            margin-top: 0;
            color: #333;
            font-size: 24px;
        }

        h2 {
            color: #555;
            font-size: 18px;
            margin: 20px 0 10px 0;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 5px;
        }

        h3 {
            color: #666;
            font-size: 16px;
            margin: 15px 0 8px 0;
        }

        .input-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #333;
        }

        textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            resize: vertical;
            font-family: monospace;
            font-size: 13px;
            transition: border-color 0.2s, background-color 0.2s;
        }
        
        textarea.invalid {
            border-color: #dc3545;
            background-color: #fff5f5;
        }
        
        .validation-error {
            color: #dc3545;
            font-size: 12px;
            margin-top: 5px;
            font-weight: 500;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
            font-size: 13px;
        }

        th,
        td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        th {
            background-color: #f8f9fa;
            font-weight: 600;
        }

        .attachments-table input {
            width: 100%;
            border: none;
            padding: 4px;
            font-family: monospace;
            font-size: 12px;
        }

        .attachments-table select {
            width: 100%;
            border: none;
            padding: 4px;
            font-size: 12px;
            min-width: 100px;
        }

        .attachments-table th:nth-child(3),
        .attachments-table td:nth-child(3) {
            min-width: 120px;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: background-color 0.2s;
        }

        button:hover {
            opacity: 0.9;
        }

        .btn-primary {
            background-color: #007bff;
            color: white;
        }

        .btn-success {
            background-color: #28a745;
            color: white;
        }

        .btn-warning {
            background-color: #ffc107;
            color: #212529;
        }

        .btn-secondary {
            background-color: #6c757d;
            color: white;
        }

        .log-container {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 10px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
        }

        .log-entry {
            margin: 2px 0;
            padding: 2px 4px;
            border-radius: 3px;
        }

        .log-entry.pass {
            background-color: #d4edda;
            color: #155724;
        }

        .log-entry.fail {
            background-color: #f8d7da;
            color: #721c24;
        }

        .log-entry.vault-removed {
            background-color: #fff3cd;
            color: #856404;
            font-weight: bold;
        }

        .arrays-display {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
        }

        .empty-state {
            color: #6c757d;
            font-style: italic;
            text-align: center;
            padding: 20px;
        }

        .step-panel {
            margin-bottom: 20px;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            overflow: hidden;
        }

        .step-header {
            background-color: #f8f9fa;
            padding: 10px 15px;
            border-bottom: 1px solid #e9ecef;
            font-weight: 600;
            color: #495057;
        }

        .step-content {
            padding: 15px;
        }

        .removed-vaults {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 4px;
            padding: 10px;
            color: #856404;
        }

        .add-row-btn {
            background-color: #17a2b8;
            color: white;
            font-size: 12px;
            padding: 4px 8px;
        }

        .req-link {
            color: #007bff;
            cursor: pointer;
            text-decoration: underline;
        }

        .req-link:hover {
            color: #0056b3;
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 20px;
            border-radius: 8px;
            width: 80%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 1px solid #e9ecef;
            padding-bottom: 10px;
        }

        .modal-title {
            margin: 0;
            color: #333;
        }

        .close {
            font-size: 24px;
            font-weight: bold;
            color: #aaa;
            cursor: pointer;
            border: none;
            background: none;
        }

        .close:hover {
            color: #000;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #e9ecef;
        }

        .btn-approve {
            background-color: #28a745;
            color: white;
        }

        .btn-reject {
            background-color: #dc3545;
            color: white;
        }

        /* Wizard Styles */
        .wizard-header {
            margin-bottom: 30px;
        }

        .wizard-steps {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding: 0;
            list-style: none;
        }

        .wizard-step {
            flex: 1;
            text-align: center;
            position: relative;
            padding: 10px 5px;
        }

        .wizard-step:not(:last-child):after {
            content: '';
            position: absolute;
            top: 20px;
            right: -50%;
            width: 100%;
            height: 2px;
            background-color: #e0e0e0;
            z-index: 1;
        }

        .wizard-step.active:not(:last-child):after {
            background-color: #007bff;
        }

        .wizard-step.completed:not(:last-child):after {
            background-color: #28a745;
        }

        .step-indicator {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 8px;
            font-weight: bold;
            position: relative;
            z-index: 2;
            background-color: #e0e0e0;
            color: #666;
            border: 3px solid #e0e0e0;
        }

        .wizard-step.active .step-indicator {
            background-color: #007bff;
            border-color: #007bff;
            color: white;
        }

        .wizard-step.completed .step-indicator {
            background-color: #28a745;
            border-color: #28a745;
            color: white;
        }

        .step-label {
            font-size: 12px;
            color: #666;
            font-weight: 500;
        }

        .wizard-step.active .step-label {
            color: #007bff;
            font-weight: 600;
        }

        .wizard-step.completed .step-label {
            color: #28a745;
        }

        .wizard-content {
            min-height: 400px;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 6px;
            border: 1px solid #e9ecef;
        }

        .wizard-navigation {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }

        .wizard-nav-left {
            display: flex;
            gap: 10px;
        }

        .wizard-nav-right {
            display: flex;
            gap: 10px;
        }

        /* Table Status Styling & Animations */
        .attachment-row {
            transition: all 0.3s ease;
        }

        .attachment-row.pending-add {
            background: linear-gradient(90deg, rgba(40, 167, 69, 0.1) 0%, rgba(40, 167, 69, 0.05) 100%);
            border-left: 4px solid #28a745;
            animation: pulse-add 2s infinite;
        }

        .attachment-row.pending-remove {
            background: linear-gradient(90deg, rgba(220, 53, 69, 0.1) 0%, rgba(220, 53, 69, 0.05) 100%);
            border-left: 4px solid #dc3545;
            animation: pulse-remove 2s infinite;
        }

        .attachment-row.final {
            background: rgba(0, 123, 255, 0.02);
            border-left: 4px solid transparent;
        }

        @keyframes pulse-add {

            0%,
            100% {
                box-shadow: 0 0 0 0 rgba(40, 167, 69, 0.3);
                border-left-color: #28a745;
            }

            50% {
                box-shadow: 0 0 0 4px rgba(40, 167, 69, 0.1);
                border-left-color: #34ce57;
            }
        }

        @keyframes pulse-remove {

            0%,
            100% {
                box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.3);
                border-left-color: #dc3545;
            }

            50% {
                box-shadow: 0 0 0 4px rgba(220, 53, 69, 0.1);
                border-left-color: #e85a6b;
            }
        }

        /* Status indicators */
        .status-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            min-width: 70px;
            text-align: center;
            transition: all 0.2s ease;
        }

        .status-badge.final {
            background-color: #e3f2fd;
            color: #1565c0;
            border: 1px solid #bbdefb;
        }

        .status-badge.pending-add {
            background-color: #e8f5e8;
            color: #2e7d32;
            border: 1px solid #c8e6c9;
            animation: glow-add 1.5s ease-in-out infinite alternate;
        }

        .status-badge.pending-remove {
            background-color: #ffebee;
            color: #c62828;
            border: 1px solid #ffcdd2;
            animation: glow-remove 1.5s ease-in-out infinite alternate;
        }

        @keyframes glow-add {
            from {
                box-shadow: 0 0 2px rgba(40, 167, 69, 0.3);
            }

            to {
                box-shadow: 0 0 6px rgba(40, 167, 69, 0.6);
            }
        }

        @keyframes glow-remove {
            from {
                box-shadow: 0 0 2px rgba(220, 53, 69, 0.3);
            }

            to {
                box-shadow: 0 0 6px rgba(220, 53, 69, 0.6);
            }
        }

        /* Req ID styling */
        .req-link {
            color: #007bff;
            cursor: pointer;
            text-decoration: none;
            font-weight: 600;
            padding: 2px 6px;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 11px;
            background-color: rgba(0, 123, 255, 0.1);
            border: 1px solid rgba(0, 123, 255, 0.2);
        }

        .req-link:hover {
            color: white;
            background-color: #007bff;
            border-color: #007bff;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 123, 255, 0.3);
        }

        /* Table enhancements */
        .attachments-table {
            border-collapse: separate;
            border-spacing: 0;
            overflow: hidden;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .attachments-table thead th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: 600;
            text-transform: uppercase;
            font-size: 11px;
            letter-spacing: 0.5px;
            padding: 12px 8px;
            border: none;
        }

        .attachments-table tbody tr:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        /* Animation Styles */
        .wizard-applying {
            position: relative;
            overflow: hidden;
        }

        .wizard-applying::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(40, 167, 69, 0.4), transparent);
            animation: applying-sweep 2s ease-in-out;
        }

        @keyframes applying-sweep {
            0% {
                left: -100%;
            }

            50% {
                left: 100%;
            }

            100% {
                left: 100%;
            }
        }

        .success-bounce {
            animation: success-bounce 0.6s ease-out;
        }

        @keyframes success-bounce {
            0% {
                transform: scale(1);
            }

            30% {
                transform: scale(1.05);
            }

            60% {
                transform: scale(0.95);
            }

            100% {
                transform: scale(1);
            }
        }


        /* Table row animations for different actions */
        .row-becoming-final {
            animation: becoming-final 1.2s ease-out forwards;
        }

        .row-being-removed {
            animation: being-removed 1s ease-out forwards;
        }

        .row-being-reverted {
            animation: being-reverted 1s ease-out forwards;
        }

        .row-newly-added {
            animation: newly-added 1s ease-out forwards;
        }

        @keyframes becoming-final {
            0% {
                transform: scale(1);
                background: linear-gradient(90deg, rgba(40, 167, 69, 0.3) 0%, rgba(40, 167, 69, 0.1) 100%);
                border-left: 4px solid #28a745;
            }

            30% {
                transform: scale(1.03);
                background: linear-gradient(90deg, rgba(40, 167, 69, 0.4) 0%, rgba(40, 167, 69, 0.2) 100%);
                border-left: 4px solid #34ce57;
                box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
            }

            70% {
                background: linear-gradient(90deg, rgba(40, 167, 69, 0.2) 0%, rgba(40, 167, 69, 0.1) 100%);
            }

            100% {
                transform: scale(1);
                background: rgba(0, 123, 255, 0.02);
                border-left: 4px solid transparent;
                box-shadow: none;
            }
        }

        @keyframes being-removed {
            0% {
                transform: scale(1);
                opacity: 1;
                background: linear-gradient(90deg, rgba(220, 53, 69, 0.1) 0%, rgba(220, 53, 69, 0.05) 100%);
            }

            30% {
                transform: scale(0.98);
                background: linear-gradient(90deg, rgba(220, 53, 69, 0.2) 0%, rgba(220, 53, 69, 0.1) 100%);
                border-left: 4px solid #e85a6b;
            }

            60% {
                transform: scale(0.95);
                opacity: 0.7;
                background: linear-gradient(90deg, rgba(220, 53, 69, 0.15) 0%, rgba(220, 53, 69, 0.08) 100%);
            }

            100% {
                transform: scale(0.9);
                opacity: 0;
                height: 0;
                padding: 0;
                margin: 0;
                border: none;
            }
        }

        @keyframes being-reverted {
            0% {
                transform: scale(1);
                background: linear-gradient(90deg, rgba(220, 53, 69, 0.1) 0%, rgba(220, 53, 69, 0.05) 100%);
                border-left: 4px solid #dc3545;
            }

            25% {
                transform: scale(1.02) rotateZ(-1deg);
                background: linear-gradient(90deg, rgba(255, 193, 7, 0.2) 0%, rgba(255, 193, 7, 0.1) 100%);
                border-left: 4px solid #ffc107;
            }

            50% {
                transform: scale(1) rotateZ(1deg);
                background: linear-gradient(90deg, rgba(255, 193, 7, 0.15) 0%, rgba(255, 193, 7, 0.08) 100%);
            }

            75% {
                transform: scale(1) rotateZ(-0.5deg);
                background: linear-gradient(90deg, rgba(0, 123, 255, 0.1) 0%, rgba(0, 123, 255, 0.05) 100%);
                border-left: 4px solid #007bff;
            }

            100% {
                transform: scale(1) rotateZ(0deg);
                background: rgba(0, 123, 255, 0.02);
                border-left: 4px solid transparent;
            }
        }

        @keyframes newly-added {
            0% {
                transform: scale(0.9) translateY(-10px);
                opacity: 0;
                background: rgba(40, 167, 69, 0.3);
            }

            30% {
                transform: scale(1.05) translateY(0);
                opacity: 0.8;
                background: rgba(40, 167, 69, 0.2);
                border-left: 4px solid #28a745;
            }

            60% {
                transform: scale(1.02);
                opacity: 1;
            }

            100% {
                transform: scale(1);
                opacity: 1;
                background: linear-gradient(90deg, rgba(40, 167, 69, 0.1) 0%, rgba(40, 167, 69, 0.05) 100%);
                border-left: 4px solid #28a745;
            }
        }

        /* Progress spinner for applying */
        .applying-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #28a745;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 8px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Edge Cases Simulator Styles */
        .edge-cases-section {
            margin-top: 30px;
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            border: 1px solid #e9ecef;
        }

        .edge-cases-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }

        .edge-cases-title {
            font-size: 16px;
            font-weight: 600;
            color: #495057;
            margin: 0;
            margin-right: 10px;
        }

        .refresh-edge-cases {
            background: #17a2b8;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 11px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .refresh-edge-cases:hover {
            background: #138496;
        }

        .edge-cases-list {
            display: grid;
            gap: 10px;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
        }

        .edge-case-item {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 12px;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .edge-case-item:hover {
            border-color: #007bff;
            box-shadow: 0 2px 8px rgba(0, 123, 255, 0.15);
            transform: translateY(-1px);
        }

        .edge-case-title {
            font-size: 12px;
            font-weight: 600;
            color: #007bff;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .edge-case-description {
            font-size: 13px;
            color: #495057;
            line-height: 1.4;
            margin-bottom: 8px;
        }

        .edge-case-inputs {
            font-size: 11px;
            color: #6c757d;
            background: #f8f9fa;
            border-radius: 3px;
            padding: 4px 6px;
            font-family: monospace;
        }

        .edge-case-empty {
            text-align: center;
            color: #6c757d;
            font-style: italic;
            padding: 20px;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>Tagging Workflow Simulator V2</h1>
        <div style="background: #e3f2fd; border: 1px solid #90caf9; border-radius: 4px; padding: 10px; margin-bottom: 20px; font-size: 13px; color: #1565c0;">
            <strong>V2 Behavior:</strong> Vault removal only occurs on capacity exceeded. Individual pairs are rejected for: already exists, pending states, or attachment not found.
        </div>

        <div class="main-layout">
            <div class="wizard-area">
                <div class="wizard-header">
                    <ul class="wizard-steps">
                        <li class="wizard-step active" data-step="1">
                            <div class="step-indicator">1</div>
                            <div class="step-label">Inputs</div>
                        </li>
                        <li class="wizard-step" data-step="2">
                            <div class="step-indicator">2</div>
                            <div class="step-label">Candidates</div>
                        </li>
                        <li class="wizard-step" data-step="3">
                            <div class="step-indicator">3</div>
                            <div class="step-label">Sanitization</div>
                        </li>
                        <li class="wizard-step" data-step="4">
                            <div class="step-indicator">4</div>
                            <div class="step-label">Review</div>
                        </li>
                        <li class="wizard-step" data-step="5">
                            <div class="step-indicator">5</div>
                            <div class="step-label">Apply</div>
                        </li>
                    </ul>
                </div>

                <div class="wizard-content" id="wizardContent">
                    <!-- Step 1 content loads here on page load -->
                </div>

                <div class="wizard-navigation">
                    <div class="wizard-nav-left">
                        <button class="btn-secondary" id="prevBtn" onclick="previousStep()" disabled>Previous</button>
                        <button class="btn-secondary" onclick="resetWizard()">Reset</button>
                    </div>
                    <div class="wizard-nav-right">
                        <button class="btn-primary" id="nextBtn" onclick="nextStep()">Next</button>
                    </div>
                </div>
            </div>

            <div class="table-area">
                <h2>Attachments Table</h2>
                <div id="attachmentsTableContainer">
                    <table class="attachments-table">
                        <thead>
                            <tr>
                                <th>Vault ID</th>
                                <th>Tag ID</th>
                                <th>Status</th>
                                <th>Req ID</th>
                                <th>Action</th>
                            </tr>
                        </thead>
                        <tbody id="attachmentsTableBody">
                        </tbody>
                    </table>
                    <button class="add-row-btn" onclick="addAttachmentRow()">+ Add Row</button>
                </div>

                <div class="edge-cases-section">
                    <div class="edge-cases-header">
                        <h3 class="edge-cases-title">Edge Cases Simulator</h3>
                        <button class="refresh-edge-cases" onclick="generateEdgeCases()">ðŸ”„ Refresh</button>
                    </div>
                    <div id="edgeCasesList" class="edge-cases-list">
                        <div class="edge-case-empty">Analyzing current table state...</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Request Modal -->
    <div id="requestModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title" id="modalTitle">Request Details</h3>
                <button class="close" onclick="closeRequestModal()">&times;</button>
            </div>
            <div id="modalBody">
                <!-- Request details will be populated here -->
            </div>
            <div class="modal-buttons">
                <button class="btn-approve" onclick="approveRequest()">Approve</button>
                <button class="btn-reject" onclick="rejectRequest()">Reject</button>
                <button class="btn-secondary" onclick="closeRequestModal()">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let currentAttachments = [];
        let currentCandidates = [];
        let currentValidPairs = [];
        let currentRemovedVaults = [];
        let currentSanitizationLog = [];
        let currentModalReqId = null;
        let requestMetadata = {}; // Store request metadata by reqId
        let currentWizardStep = 1;
        const maxSteps = 5;

        // Initialize with random starter data
        function initializeStarterData() {
            currentAttachments = generateRandomAttachments();

            renderAttachmentsTable();
            clearResults();
            generateEdgeCases(); // Generate initial edge cases
        }

        function generateRandomAttachments() {
            const attachments = [];
            const vaultIds = ['v1', 'v2', 'v3', 'v4', 'v5'];
            const tagIds = ['t1', 't2', 't3', 't4', 't5', 't6', 't7', 't8', 't9', 't10'];
            const statuses = ['final', 'pending add', 'pending remove'];
            
            // Generate 3-7 random attachments
            const numAttachments = Math.floor(Math.random() * 5) + 3;
            const usedPairs = new Set();
            
            for (let i = 0; i < numAttachments; i++) {
                let vaultId, tagId, pair;
                
                // Ensure unique vault-tag pairs
                do {
                    vaultId = vaultIds[Math.floor(Math.random() * vaultIds.length)];
                    tagId = tagIds[Math.floor(Math.random() * tagIds.length)];
                    pair = `${vaultId}:${tagId}`;
                } while (usedPairs.has(pair));
                
                usedPairs.add(pair);
                
                // Determine status - favor final attachments (70% chance)
                let status;
                const statusRand = Math.random();
                if (statusRand < 0.7) {
                    status = 'final';
                } else if (statusRand < 0.85) {
                    status = 'pending add';
                } else {
                    status = 'pending remove';
                }
                
                let reqId = null;
                
                // Add reqId for pending attachments
                if (status.startsWith('pending')) {
                    reqId = `REQ-${String(Math.floor(Math.random() * 999) + 1).padStart(3, '0')}`;
                    
                    // Add metadata for this request
                    if (!requestMetadata[reqId]) {
                        requestMetadata[reqId] = {
                            vaults: [vaultId],
                            tagsToAdd: status === 'pending add' ? [tagId] : [],
                            tagsToRemove: status === 'pending remove' ? [tagId] : [],
                            timestamp: new Date(Date.now() - Math.random() * 7 * 24 * 60 * 60 * 1000).toISOString()
                        };
                    }
                }
                
                attachments.push({
                    vaultId,
                    tagId, 
                    status,
                    reqId
                });
            }
            
            return attachments;
        }

        // Edge Cases Simulator Functions
        function generateEdgeCases() {
            const edgeCases = [];
            const vaults = [...new Set(currentAttachments.map(att => att.vaultId))];
            const tags = [...new Set(currentAttachments.map(att => att.tagId))];

            // Analyze current state
            const finalAttachments = currentAttachments.filter(att => att.status === 'final');
            const pendingAddAttachments = currentAttachments.filter(att => att.status === 'pending add');
            const pendingRemoveAttachments = currentAttachments.filter(att => att.status === 'pending remove');

            // Edge Case 1: Try to add existing final attachment
            if (finalAttachments.length > 0) {
                const target = finalAttachments[0];
                edgeCases.push({
                    title: 'Add Existing Final',
                    description: `Try to add ${target.tagId} to ${target.vaultId} which already exists as final`,
                    vaults: [target.vaultId],
                    addTags: [target.tagId],
                    removeTags: [],
                    expectedResult: 'Should be rejected: already exists'
                });
            }

            // Edge Case 2: Try to remove non-existent attachment
            if (vaults.length > 0 && tags.length > 0) {
                const vault = vaults[0];
                const unusedTag = `t${Math.floor(Math.random() * 1000)}`;
                edgeCases.push({
                    title: 'Remove Non-existent',
                    description: `Try to remove ${unusedTag} from ${vault} which doesn't exist`,
                    vaults: [vault],
                    addTags: [],
                    removeTags: [unusedTag],
                    expectedResult: 'Should be rejected: attachment does not exist'
                });
            }

            // Edge Case 3: Try to add to pending add attachment
            if (pendingAddAttachments.length > 0) {
                const target = pendingAddAttachments[0];
                edgeCases.push({
                    title: 'Add to Pending Add',
                    description: `Try to add ${target.tagId} to ${target.vaultId} which has pending add`,
                    vaults: [target.vaultId],
                    addTags: [target.tagId],
                    removeTags: [],
                    expectedResult: 'Should be rejected: pending request exists'
                });
            }

            // Edge Case 4: Try to remove pending add attachment
            if (pendingAddAttachments.length > 0) {
                const target = pendingAddAttachments[0];
                edgeCases.push({
                    title: 'Remove Pending Add',
                    description: `Try to remove ${target.tagId} from ${target.vaultId} which has pending add`,
                    vaults: [target.vaultId],
                    addTags: [],
                    removeTags: [target.tagId],
                    expectedResult: 'Should be rejected: pending request exists'
                });
            }

            // Edge Case 5: Try to add to pending remove attachment
            if (pendingRemoveAttachments.length > 0) {
                const target = pendingRemoveAttachments[0];
                edgeCases.push({
                    title: 'Add to Pending Remove',
                    description: `Try to add ${target.tagId} to ${target.vaultId} which has pending remove`,
                    vaults: [target.vaultId],
                    addTags: [target.tagId],
                    removeTags: [],
                    expectedResult: 'Should be rejected: pending request exists'
                });
            }

            // Edge Case 6: Try to remove pending remove attachment
            if (pendingRemoveAttachments.length > 0) {
                const target = pendingRemoveAttachments[0];
                edgeCases.push({
                    title: 'Remove Pending Remove',
                    description: `Try to remove ${target.tagId} from ${target.vaultId} which has pending remove`,
                    vaults: [target.vaultId],
                    addTags: [],
                    removeTags: [target.tagId],
                    expectedResult: 'Should be rejected: pending request exists'
                });
            }

            // Edge Case 7: Capacity limit test
            const vaultCounts = new Map();
            currentAttachments.forEach(att => {
                if (att.status !== 'pending remove') {
                    vaultCounts.set(att.vaultId, (vaultCounts.get(att.vaultId) || 0) + 1);
                }
            });
            const vaultNearCapacity = [...vaultCounts.entries()].find(([v, count]) => count === 2);
            if (vaultNearCapacity) {
                const [vault] = vaultNearCapacity;
                const newTag = `t${Math.floor(Math.random() * 1000)}`;
                edgeCases.push({
                    title: 'Test Capacity Limit',
                    description: `Try to add 2 tags to ${vault} which has 2 attachments (would exceed limit of 3)`,
                    vaults: [vault],
                    addTags: [newTag, `${newTag}x`],
                    removeTags: [],
                    expectedResult: 'Should accept first tag, then fail on capacity and purge vault'
                });
            }

            // Edge Case 8: Conflict resolution (same vault-tag in add and remove)
            if (finalAttachments.length > 0) {
                const target = finalAttachments[0];
                edgeCases.push({
                    title: 'Add/Remove Conflict',
                    description: `Try to both add and remove ${target.tagId} on ${target.vaultId} (remove should win)`,
                    vaults: [target.vaultId],
                    addTags: [target.tagId],
                    removeTags: [target.tagId],
                    expectedResult: 'Should generate only remove candidate, removing existing attachment'
                });
            }

            // Edge Case 9: Sequential vault failure
            if (vaults.length >= 2 && finalAttachments.length > 0) {
                const target = finalAttachments[0];
                const otherVault = vaults.find(v => v !== target.vaultId);
                if (otherVault) {
                    edgeCases.push({
                        title: 'Sequential Vault Failure',
                        description: `Add existing ${target.tagId} to ${target.vaultId}, then valid tag to ${otherVault}`,
                        vaults: [target.vaultId, otherVault],
                        addTags: [target.tagId],
                        removeTags: [],
                        expectedResult: `V2: Should reject pair on ${target.vaultId} (no vault removal), then succeed on ${otherVault}`
                    });
                }
            }
            
            // Edge Case 10: Mixed vault success/failure - First vault fails, others succeed
            if (vaults.length >= 3 && finalAttachments.length > 0) {
                const failingVault = finalAttachments[0].vaultId;
                const existingTag = finalAttachments[0].tagId;
                const otherVaults = vaults.filter(v => v !== failingVault).slice(0, 2);
                
                if (otherVaults.length >= 2) {
                    const newTag = `t${Math.floor(Math.random() * 1000)}`;
                    edgeCases.push({
                        title: 'First Vault Fails, Others Pass',
                        description: `Try to add existing ${existingTag} to ${failingVault} (fails), while adding ${newTag} to ${otherVaults.join(' and ')} (should succeed)`,
                        vaults: [failingVault, ...otherVaults],
                        addTags: [existingTag, newTag],
                        removeTags: [],
                        expectedResult: `V2: Should reject pairs on ${failingVault} (no vault removal), succeed on ${otherVaults.join(' and ')}`
                    });
                }
            }
            
            // Edge Case 11: Middle vault fails due to capacity
            const vaultsWithCounts = [...vaultCounts.entries()];
            const vaultAt2 = vaultsWithCounts.find(([v, count]) => count === 2);
            if (vaultAt2 && vaults.length >= 3) {
                const [capacityVault] = vaultAt2;
                const otherVaults = vaults.filter(v => v !== capacityVault).slice(0, 2);
                
                if (otherVaults.length >= 2) {
                    const newTag1 = `t${Math.floor(Math.random() * 1000)}`;
                    const newTag2 = `t${Math.floor(Math.random() * 1000) + 100}`;
                    edgeCases.push({
                        title: 'Middle Vault Capacity Failure',
                        description: `Add ${newTag1} to ${otherVaults[0]}, then 2 tags to ${capacityVault} (capacity fail), then ${newTag2} to ${otherVaults[1]}`,
                        vaults: otherVaults[0] ? [otherVaults[0], capacityVault, otherVaults[1]] : [capacityVault],
                        addTags: [newTag1, newTag1 + 'x', newTag1 + 'y', newTag2],
                        removeTags: [],
                        expectedResult: `First vault succeeds, middle vault fails on capacity and gets purged, last vault succeeds`
                    });
                }
            }
            
            // Edge Case 12: Multiple vault failures with success in between
            if (vaults.length >= 3 && finalAttachments.length >= 2) {
                const failTargets = finalAttachments.slice(0, 2);
                const successVault = vaults.find(v => !failTargets.some(f => f.vaultId === v));
                
                if (successVault && failTargets.length >= 2) {
                    const newTag = `t${Math.floor(Math.random() * 1000)}`;
                    edgeCases.push({
                        title: 'Multiple Failures With Success',
                        description: `Try to add existing tags to ${failTargets[0].vaultId} and ${failTargets[1].vaultId} (both fail), but new tag to ${successVault} (succeeds)`,
                        vaults: [failTargets[0].vaultId, successVault, failTargets[1].vaultId],
                        addTags: [failTargets[0].tagId, newTag, failTargets[1].tagId],
                        removeTags: [],
                        expectedResult: `V2: Should reject pairs on ${failTargets[0].vaultId} and ${failTargets[1].vaultId} (no vault removal), succeed on ${successVault}`
                    });
                }
            }
            
            // Edge Case 13: Pending attachment mixed with success
            if (pendingAddAttachments.length > 0 && vaults.length >= 2) {
                const pendingTarget = pendingAddAttachments[0];
                const successVault = vaults.find(v => v !== pendingTarget.vaultId);
                
                if (successVault) {
                    const newTag = `t${Math.floor(Math.random() * 1000)}`;
                    edgeCases.push({
                        title: 'Pending Conflict + Success',
                        description: `Try to add ${pendingTarget.tagId} to ${pendingTarget.vaultId} (has pending, should fail) and ${newTag} to ${successVault} (should succeed)`,
                        vaults: [pendingTarget.vaultId, successVault],
                        addTags: [pendingTarget.tagId, newTag],
                        removeTags: [],
                        expectedResult: `V2: Should reject pair on ${pendingTarget.vaultId} (no vault removal), succeed on ${successVault}`
                    });
                }
            }

            renderEdgeCases(edgeCases);
        }

        function renderEdgeCases(edgeCases) {
            const container = document.getElementById('edgeCasesList');

            if (edgeCases.length === 0) {
                container.innerHTML = '<div class="edge-case-empty">No edge cases found for current table state</div>';
                return;
            }

            container.innerHTML = edgeCases.map((edgeCase, index) => `
                <div class="edge-case-item" onclick="applyEdgeCase(${index})">
                    <div class="edge-case-title">${edgeCase.title}</div>
                    <div class="edge-case-description">${edgeCase.description}</div>
                    <div class="edge-case-inputs">
                        Vaults: [${edgeCase.vaults.join(', ')}] | 
                        Add: [${edgeCase.addTags.join(', ') || 'none'}] | 
                        Remove: [${edgeCase.removeTags.join(', ') || 'none'}]
                    </div>
                </div>
            `).join('');

            // Store edge cases globally for click handlers
            window.currentEdgeCases = edgeCases;
        }

        function applyEdgeCase(index) {
            const edgeCase = window.currentEdgeCases[index];
            if (!edgeCase) return;

            // Reset wizard state first
            resetWizard();
            
            // Set inputs
            document.getElementById('vaults').value = edgeCase.vaults.join(', ');
            document.getElementById('tagsToAdd').value = edgeCase.addTags.join(', ');
            document.getElementById('tagsToRemove').value = edgeCase.removeTags.join(', ');

            // Validate and update preview to reflect the new inputs
            setTimeout(() => validateInputs(), 50);

            // Show a brief indication
            const item = event.target.closest('.edge-case-item');
            item.style.background = '#e3f2fd';
            setTimeout(() => {
                item.style.background = 'white';
            }, 300);
        }

        // Parse comma or newline separated list
        function parseList(str) {
            if (!str || typeof str !== 'string') return [];
            return str.split(/[,\n]/)
                .map(item => item.trim())
                .filter(item => item.length > 0)
                .filter((item, index, array) => array.indexOf(item) === index); // dedupe
        }

        // Build candidates with conflict resolution
        function buildCandidates(vaults, addTags, removeTags) {
            const candidates = [];
            const conflicts = new Set(); // track (vault,tag) pairs that have conflicts

            // First pass: identify conflicts
            for (const vault of vaults) {
                for (const tag of addTags) {
                    if (removeTags.includes(tag)) {
                        conflicts.add(`${vault}:${tag}`);
                    }
                }
            }

            // Second pass: generate candidates, preferring remove for conflicts
            for (const vault of vaults) {
                // Add candidates
                for (const tag of addTags) {
                    const key = `${vault}:${tag}`;
                    if (!conflicts.has(key)) {
                        candidates.push({ vaultId: vault, tagId: tag, action: 'add' });
                    }
                }

                // Remove candidates (always included, even for conflicts)
                for (const tag of removeTags) {
                    candidates.push({ vaultId: vault, tagId: tag, action: 'remove' });
                }
            }

            return candidates;
        }

        // Sanitize candidates with selective vault removal (V2 Behavior)
        function sanitizeCandidates(candidates, attachments) {
            const removedVaults = new Set();
            const validPairs = [];
            const validPairCount = new Map();
            const log = [];

            for (let i = 0; i < candidates.length; i++) {
                const candidate = candidates[i];
                const { vaultId, tagId, action } = candidate;

                let isValid = true;
                let reason = '';
                let shouldRemoveVault = false;

                // Rule 1: Check if vault was removed earlier
                if (removedVaults.has(vaultId)) {
                    isValid = false;
                    reason = 'vault removed earlier';
                } else if (action === 'add') {
                    // Rule 2a: Check if attachment already exists or has pending request
                    const existingAttachment = attachments.find(att =>
                        att.vaultId === vaultId && att.tagId === tagId
                    );
                    if (existingAttachment && existingAttachment.status === 'final') {
                        isValid = false;
                        reason = 'already exists';
                        // V2: Don't remove vault, just reject this pair
                    } else if (existingAttachment && existingAttachment.status.startsWith('pending')) {
                        isValid = false;
                        reason = 'pending request exists';
                        // V2: Don't remove vault, just reject this pair
                    } else {
                        // Rule 2b: Check capacity limit (count existing + pending + current batch + this candidate)
                        const existingCount = attachments.filter(att =>
                            att.vaultId === vaultId && att.status !== 'pending remove'
                        ).length;
                        const currentBatchCount = validPairCount.get(vaultId) || 0;
                        const totalCountAfterAdding = existingCount + currentBatchCount + 1;

                        if (totalCountAfterAdding > 3) {
                            isValid = false;
                            reason = 'capacity reached (max 3)';
                            shouldRemoveVault = true; // V2: Only remove vault on capacity exceeded
                        }
                    }
                } else if (action === 'remove') {
                    // Rule 3: Can only remove existing final attachments, not pending ones
                    const existingAttachment = attachments.find(att =>
                        att.vaultId === vaultId && att.tagId === tagId
                    );
                    if (!existingAttachment) {
                        isValid = false;
                        reason = 'attachment does not exist';
                        // V2: Don't remove vault, just reject this pair
                    } else if (existingAttachment.status.startsWith('pending')) {
                        isValid = false;
                        reason = 'pending request exists';
                        // V2: Don't remove vault, just reject this pair
                    } else if (existingAttachment.status !== 'final') {
                        isValid = false;
                        reason = 'not a final attachment';
                        // V2: Don't remove vault, just reject this pair
                    }
                }

                if (isValid) {
                    // Accept the candidate
                    validPairs.push(candidate);
                    validPairCount.set(vaultId, (validPairCount.get(vaultId) || 0) + 1);
                    log.push({
                        step: i + 1,
                        candidate: candidate,
                        status: 'PASS',
                        reason: 'accepted'
                    });
                } else {
                    // Log the failure
                    log.push({
                        step: i + 1,
                        candidate: candidate,
                        status: 'FAIL',
                        reason: reason
                    });

                    // V2: Only remove vault if it's a capacity issue
                    if (shouldRemoveVault && !removedVaults.has(vaultId)) {
                        // Remove vault due to capacity exceeded
                        removedVaults.add(vaultId);

                        // Purge previously accepted pairs for this vault
                        const originalLength = validPairs.length;
                        for (let j = validPairs.length - 1; j >= 0; j--) {
                            if (validPairs[j].vaultId === vaultId) {
                                validPairs.splice(j, 1);
                            }
                        }

                        // Reset count
                        validPairCount.set(vaultId, 0);

                        log.push({
                            step: i + 1,
                            candidate: candidate,
                            status: 'VAULT_REMOVED',
                            reason: `Vault ${vaultId} removed due to capacity exceeded`,
                            vaultRemoved: true
                        });
                    }
                    // V2: For non-capacity failures, just reject the individual pair
                }
            }

            return {
                validPairs: validPairs,
                removedVaults: Array.from(removedVaults),
                log: log
            };
        }

        // Apply valid pairs to attachments table
        function applyValidPairs(validPairs, attachments) {
            let newAttachments = [...attachments];

            // Generate unique request ID for this batch
            const reqId = `REQ-${String(Date.now()).slice(-6)}`;

            // Extract the applied vaults and tags from validPairs
            const appliedVaults = [...new Set(validPairs.map(p => p.vaultId))];
            const appliedAddTags = [...new Set(validPairs.filter(p => p.action === 'add').map(p => p.tagId))];
            const appliedRemoveTags = [...new Set(validPairs.filter(p => p.action === 'remove').map(p => p.tagId))];

            // Store metadata for this request
            requestMetadata[reqId] = {
                vaults: appliedVaults,
                tagsToAdd: appliedAddTags,
                tagsToRemove: appliedRemoveTags,
                timestamp: new Date().toISOString()
            };

            for (const pair of validPairs) {
                const { vaultId, tagId, action } = pair;

                if (action === 'add') {
                    // Add new pending row only if not already present
                    const exists = newAttachments.find(att =>
                        att.vaultId === vaultId && att.tagId === tagId
                    );

                    if (!exists) {
                        newAttachments.push({ vaultId, tagId, status: 'pending add', reqId });
                    }
                } else if (action === 'remove') {
                    // Update existing row status to pending remove
                    const existingRow = newAttachments.find(att =>
                        att.vaultId === vaultId && att.tagId === tagId
                    );

                    if (existingRow) {
                        existingRow.status = 'pending remove';
                        existingRow.reqId = reqId;
                    }
                }
            }

            return newAttachments;
        }

        // Render functions
        function renderParsedInputs(vaults, addTags, removeTags) {
            const container = document.getElementById('parsedInputs');
            container.innerHTML = `
                <div><strong>Vaults:</strong> [${vaults.map(v => `"${v}"`).join(', ')}]</div>
                <div><strong>Tags To Add:</strong> [${addTags.map(t => `"${t}"`).join(', ')}]</div>
                <div><strong>Tags To Remove:</strong> [${removeTags.map(t => `"${t}"`).join(', ')}]</div>
            `;
        }

        function renderCandidatesTable(candidates) {
            const container = document.getElementById('candidatesTable');
            if (candidates.length === 0) {
                container.innerHTML = '<div class="empty-state">No candidates generated</div>';
                return;
            }

            const table = `
                <table>
                    <thead>
                        <tr>
                            <th>Vault ID</th>
                            <th>Tag ID</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${candidates.map(c => `
                            <tr>
                                <td>${c.vaultId}</td>
                                <td>${c.tagId}</td>
                                <td>${c.action}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;
            container.innerHTML = table;
        }

        function renderSanitizationLog(log) {
            const container = document.getElementById('sanitizationLog');
            if (log.length === 0) {
                container.innerHTML = '<div class="empty-state">Run sanitization to see processing log</div>';
                return;
            }

            const logEntries = log.map(entry => {
                if (entry.vaultRemoved) {
                    return `<div class="log-entry vault-removed">Step ${entry.step}: ${entry.reason}</div>`;
                } else {
                    const cssClass = entry.status === 'PASS' ? 'pass' : 'fail';
                    const candidateStr = `{${entry.candidate.vaultId}, ${entry.candidate.tagId}, ${entry.candidate.action}}`;
                    return `<div class="log-entry ${cssClass}">Step ${entry.step}: ${candidateStr} â†’ ${entry.status} (${entry.reason})</div>`;
                }
            }).join('');

            container.innerHTML = logEntries;
        }

        function renderValidPairs(validPairs) {
            const container = document.getElementById('validPairsTable');
            if (validPairs.length === 0) {
                container.innerHTML = '<div class="empty-state">No valid pairs</div>';
                return;
            }

            const table = `
                <table>
                    <thead>
                        <tr>
                            <th>Vault ID</th>
                            <th>Tag ID</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${validPairs.map(p => `
                            <tr>
                                <td>${p.vaultId}</td>
                                <td>${p.tagId}</td>
                                <td>${p.action}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;
            container.innerHTML = table;
        }

        function renderRemovedVaults(removedVaults) {
            const container = document.getElementById('removedVaults');
            if (removedVaults.length === 0) {
                container.innerHTML = '<div class="empty-state">No vaults removed</div>';
                return;
            }

            container.innerHTML = `<div class="removed-vaults">Removed vaults: ${removedVaults.join(', ')}</div>`;
        }

        function renderAttachmentsTable() {
            const tbody = document.getElementById('attachmentsTableBody');
            tbody.innerHTML = currentAttachments.map((att, index) => {
                const reqIdCell = att.reqId ?
                    `<span class="req-link" onclick="showRequestModal('${att.reqId}')">${att.reqId}</span>` :
                    '<span style="color: #6c757d;">-</span>';

                // Determine row class based on status
                let rowClass = 'attachment-row';
                if (att.status === 'pending add') {
                    rowClass += ' pending-add';
                } else if (att.status === 'pending remove') {
                    rowClass += ' pending-remove';
                } else {
                    rowClass += ' final';
                }

                // Create status badge (clickable to cycle through states)
                const statusClass = att.status.replace(' ', '-');
                const statusBadge = `<span class="status-badge ${statusClass}" onclick="cycleStatus(${index})" style="cursor: pointer;" title="Click to change status">${att.status}</span>`;

                return `
                <tr class="${rowClass}">
                    <td><input type="text" value="${att.vaultId}" onchange="updateAttachment(${index}, 'vaultId', this.value)"></td>
                    <td><input type="text" value="${att.tagId}" onchange="updateAttachment(${index}, 'tagId', this.value)"></td>
                    <td>${statusBadge}</td>
                    <td>${reqIdCell}</td>
                    <td><button class="btn-secondary" style="font-size: 11px; padding: 2px 6px;" onclick="removeAttachment(${index})">Remove</button></td>
                </tr>
            `;
            }).join('');

            // Refresh edge cases when table changes
            generateEdgeCases();
        }

        function renderUpdatedAttachments(attachments) {
            const container = document.getElementById('updatedAttachmentsTable');
            if (attachments.length === 0) {
                container.innerHTML = '<div class="empty-state">No attachments</div>';
                return;
            }

            const table = `
                <table>
                    <thead>
                        <tr>
                            <th>Vault ID</th>
                            <th>Tag ID</th>
                            <th>Status</th>
                            <th>Req ID</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${attachments.map(att => {
                const reqIdCell = att.reqId ?
                    `<span class="req-link" onclick="showRequestModal('${att.reqId}')">${att.reqId}</span>` :
                    '<span style="color: #6c757d;">-</span>';
                return `
                            <tr>
                                <td>${att.vaultId}</td>
                                <td>${att.tagId}</td>
                                <td>${att.status}</td>
                                <td>${reqIdCell}</td>
                            </tr>
                        `;
            }).join('')}
                    </tbody>
                </table>
            `;
            container.innerHTML = table;
        }

        // Event handlers
        function generateCandidates() {
            const vaultsStr = document.getElementById('vaults').value;
            const addTagsStr = document.getElementById('tagsToAdd').value;
            const removeTagsStr = document.getElementById('tagsToRemove').value;

            const vaults = parseList(vaultsStr);
            const addTags = parseList(addTagsStr);
            const removeTags = parseList(removeTagsStr);

            console.log('Parsed inputs:', { vaults, addTags, removeTags });

            currentCandidates = buildCandidates(vaults, addTags, removeTags);

            console.log('Generated candidates:', currentCandidates);

            renderParsedInputs(vaults, addTags, removeTags);
            renderCandidatesTable(currentCandidates);

            // Clear later steps
            currentValidPairs = [];
            currentRemovedVaults = [];
            currentSanitizationLog = [];
            renderSanitizationLog([]);
            renderValidPairs([]);
            renderRemovedVaults([]);
        }

        function runSanitization() {
            if (currentCandidates.length === 0) {
                alert('Generate candidates first');
                return;
            }

            console.log('Starting sanitization with:', {
                candidates: currentCandidates,
                attachments: currentAttachments
            });

            const result = sanitizeCandidates(currentCandidates, currentAttachments);
            currentValidPairs = result.validPairs;
            currentRemovedVaults = result.removedVaults;
            currentSanitizationLog = result.log;

            console.log('Sanitization result:', result);

            renderSanitizationLog(currentSanitizationLog);
            renderValidPairs(currentValidPairs);
            renderRemovedVaults(currentRemovedVaults);
        }

        function applyToTable() {
            if (currentValidPairs.length === 0) {
                alert('Run sanitization first to get valid pairs');
                return;
            }

            // Update the main attachments table
            currentAttachments = applyValidPairs(currentValidPairs, currentAttachments);

            // Re-render both the editable table and the results view
            renderAttachmentsTable();
            renderUpdatedAttachments(currentAttachments);
        }

        function resetData() {
            // Reset inputs
            document.getElementById('vaults').value = 'v1,v2';
            document.getElementById('tagsToAdd').value = 't1,t2';
            document.getElementById('tagsToRemove').value = 't3';

            // Reset state
            initializeStarterData();
        }

        function clearResults() {
            currentCandidates = [];
            currentValidPairs = [];
            currentRemovedVaults = [];
            currentSanitizationLog = [];

            document.getElementById('parsedInputs').innerHTML = '<div class="empty-state">Click "Generate Candidates" to see parsed inputs</div>';
            document.getElementById('candidatesTable').innerHTML = '<div class="empty-state">No candidates generated yet</div>';
            document.getElementById('sanitizationLog').innerHTML = '<div class="empty-state">Run sanitization to see processing log</div>';
            document.getElementById('validPairsTable').innerHTML = '<div class="empty-state">No valid pairs yet</div>';
            document.getElementById('removedVaults').innerHTML = '<div class="empty-state">No vaults removed yet</div>';
            document.getElementById('updatedAttachmentsTable').innerHTML = '<div class="empty-state">Apply changes to see updated table</div>';
        }

        function updateAttachment(index, field, value) {
            if (index >= 0 && index < currentAttachments.length) {
                currentAttachments[index][field] = value;
            }
        }

        function cycleStatus(index) {
            if (index >= 0 && index < currentAttachments.length) {
                const statuses = ['final', 'pending add', 'pending remove'];
                const currentStatus = currentAttachments[index].status;
                const currentIndex = statuses.indexOf(currentStatus);
                const nextIndex = (currentIndex + 1) % statuses.length;

                currentAttachments[index].status = statuses[nextIndex];
                renderAttachmentsTable();
            }
        }

        function removeAttachment(index) {
            currentAttachments.splice(index, 1);
            renderAttachmentsTable();
        }

        function addAttachmentRow() {
            currentAttachments.push({ vaultId: '', tagId: '', status: 'final', reqId: null });
            renderAttachmentsTable();
        }

        // Modal functions
        function showRequestModal(reqId) {
            currentModalReqId = reqId;
            const requestPairs = currentAttachments.filter(att => att.reqId === reqId);
            const metadata = requestMetadata[reqId];

            document.getElementById('modalTitle').textContent = `Request ${reqId}`;

            const modalBody = document.getElementById('modalBody');
            if (requestPairs.length === 0) {
                modalBody.innerHTML = '<div class="empty-state">No pairs found for this request</div>';
            } else {
                let inputsSection = '';
                if (metadata) {
                    inputsSection = `
                        <div style="background-color: #f8f9fa; padding: 15px; margin-bottom: 20px; border-radius: 6px; border-left: 4px solid #007bff;">
                            <h4 style="margin: 0 0 10px 0; color: #333;">Original Inputs (Applied)</h4>
                            <div style="font-family: monospace; font-size: 13px; line-height: 1.4;">
                                <div><strong>Vaults:</strong> [${metadata.vaults.map(v => `"${v}"`).join(', ')}]</div>
                                ${metadata.tagsToAdd.length > 0 ? `<div><strong>Tags To Add:</strong> [${metadata.tagsToAdd.map(t => `"${t}"`).join(', ')}]</div>` : ''}
                                ${metadata.tagsToRemove.length > 0 ? `<div><strong>Tags To Remove:</strong> [${metadata.tagsToRemove.map(t => `"${t}"`).join(', ')}]</div>` : ''}
                            </div>
                            <div style="margin-top: 8px; font-size: 11px; color: #6c757d;">
                                Created: ${new Date(metadata.timestamp).toLocaleString()}
                            </div>
                        </div>
                    `;
                }

                const table = `
                    <h4 style="margin: 0 0 10px 0; color: #333;">Affected Pairs</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Vault ID</th>
                                <th>Tag ID</th>
                                <th>Action</th>
                                <th>Current Status</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${requestPairs.map(pair => `
                                <tr>
                                    <td>${pair.vaultId}</td>
                                    <td>${pair.tagId}</td>
                                    <td>${pair.status.replace('pending ', '')}</td>
                                    <td><span style="color: ${pair.status === 'pending add' ? '#28a745' : '#dc3545'};">${pair.status}</span></td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                `;
                modalBody.innerHTML = inputsSection + table;
            }

            document.getElementById('requestModal').style.display = 'block';
        }

        function closeRequestModal() {
            document.getElementById('requestModal').style.display = 'none';
            currentModalReqId = null;
        }

        function approveRequest() {
            if (!currentModalReqId) return;

            // Store reqId before closing modal (which clears currentModalReqId)
            const reqId = currentModalReqId;

            // Close modal immediately
            closeRequestModal();

            // Find affected attachments and their actions before changes
            const affectedAttachments = currentAttachments
                .map((att, index) => ({ att, originalIndex: index }))
                .filter(item => item.att.reqId === reqId);

            // Process each attachment with this reqId
            currentAttachments = currentAttachments.filter(att => {
                if (att.reqId === reqId) {
                    if (att.status === 'pending remove') {
                        // Remove the attachment completely
                        return false;
                    }
                    // For pending add, convert to final
                    att.status = 'final';
                    att.reqId = null;
                }
                return true;
            });

            renderAttachmentsTable();
            renderUpdatedAttachments(currentAttachments);

            // Animate rows based on their specific changes
            setTimeout(() => {
                affectedAttachments.forEach((item, idx) => {
                    const { att } = item;

                    if (att.status === 'pending remove') {
                        // This row will be removed
                        const row = document.querySelector(`#attachmentsTableBody tr:nth-child(${item.originalIndex + 1})`);
                        if (row) {
                            row.classList.add('row-being-removed');
                            setTimeout(() => {
                                if (row.parentNode) {
                                    row.remove();
                                }
                            }, 1000);
                        }
                    } else if (att.status === 'pending add') {
                        // This row becomes final - find its new position
                        setTimeout(() => {
                            const newRows = document.querySelectorAll('#attachmentsTableBody tr');
                            const targetRow = Array.from(newRows).find(row => {
                                const vaultCell = row.cells[0].querySelector('input');
                                const tagCell = row.cells[1].querySelector('input');
                                return vaultCell && tagCell &&
                                    vaultCell.value === att.vaultId &&
                                    tagCell.value === att.tagId;
                            });
                            if (targetRow) {
                                targetRow.classList.add('row-becoming-final');
                                setTimeout(() => targetRow.classList.remove('row-becoming-final'), 1200);
                            }
                        }, 50);
                    }
                });
            }, 100);
        }

        function rejectRequest() {
            if (!currentModalReqId) return;

            // Store reqId before closing modal (which clears currentModalReqId)
            const reqId = currentModalReqId;

            // Close modal immediately
            closeRequestModal();

            // Find affected attachments and their actions before changes
            const affectedAttachments = currentAttachments
                .map((att, index) => ({ att, originalIndex: index }))
                .filter(item => item.att.reqId === reqId);

            console.log('Rejecting request:', reqId);
            console.log('Attachments before reject:', currentAttachments.filter(att => att.reqId === reqId));

            // Handle rejection based on the request type
            const newAttachments = [];

            for (const att of currentAttachments) {
                if (att.reqId === reqId) {
                    console.log('Processing attachment:', att);
                    if (att.status === 'pending add') {
                        // Remove pending add rows (they never existed)
                        console.log('Removing pending add:', att);
                        // Don't add to newAttachments (effectively removing it)
                    } else if (att.status === 'pending remove') {
                        // Revert pending remove back to final status
                        console.log('Reverting pending remove to final:', att);
                        newAttachments.push({
                            ...att,
                            status: 'final',
                            reqId: null
                        });
                    } else {
                        // Keep other statuses as-is
                        newAttachments.push(att);
                    }
                } else {
                    // Keep attachments not part of this request
                    newAttachments.push(att);
                }
            }

            currentAttachments = newAttachments;
            console.log('Attachments after reject:', currentAttachments);

            renderAttachmentsTable();
            renderUpdatedAttachments(currentAttachments);

            // Animate rows based on their specific changes
            setTimeout(() => {
                affectedAttachments.forEach((item) => {
                    const { att } = item;

                    if (att.status === 'pending add') {
                        // This row will be removed (it was never a real attachment)
                        const row = document.querySelector(`#attachmentsTableBody tr:nth-child(${item.originalIndex + 1})`);
                        if (row) {
                            row.classList.add('row-being-removed');
                            setTimeout(() => {
                                if (row.parentNode) {
                                    row.remove();
                                }
                            }, 1000);
                        }
                    } else if (att.status === 'pending remove') {
                        // This row gets reverted back to final - find its new position
                        setTimeout(() => {
                            const newRows = document.querySelectorAll('#attachmentsTableBody tr');
                            const targetRow = Array.from(newRows).find(row => {
                                const vaultCell = row.cells[0].querySelector('input');
                                const tagCell = row.cells[1].querySelector('input');
                                return vaultCell && tagCell &&
                                    vaultCell.value === att.vaultId &&
                                    tagCell.value === att.tagId;
                            });
                            if (targetRow) {
                                targetRow.classList.add('row-being-reverted');
                                setTimeout(() => targetRow.classList.remove('row-being-reverted'), 1000);
                            }
                        }, 50);
                    }
                });
            }, 100);
        }

        // Close modal when clicking outside
        window.onclick = function (event) {
            const modal = document.getElementById('requestModal');
            if (event.target === modal) {
                closeRequestModal();
            }
        }

        // Wizard Functions
        function showWizardStep(step) {
            currentWizardStep = step;

            // Update step indicators
            document.querySelectorAll('.wizard-step').forEach((el, index) => {
                const stepNum = index + 1;
                el.classList.remove('active', 'completed');

                if (stepNum === step) {
                    el.classList.add('active');
                } else if (stepNum < step) {
                    el.classList.add('completed');
                    el.querySelector('.step-indicator').textContent = 'âœ“';
                } else {
                    el.querySelector('.step-indicator').textContent = stepNum;
                }
            });

            // Update navigation buttons
            document.getElementById('prevBtn').disabled = step === 1;
            const nextBtn = document.getElementById('nextBtn');

            if (step === maxSteps) {
                nextBtn.textContent = 'Apply Changes';
                nextBtn.className = 'btn-success';
            } else {
                nextBtn.textContent = 'Next';
                nextBtn.className = 'btn-primary';
            }

            // Load step content
            loadStepContent(step);
        }

        function loadStepContent(step) {
            const content = document.getElementById('wizardContent');

            switch (step) {
                case 1:
                    content.innerHTML = getStep1Content();
                    // Show initial input preview and validate
                    setTimeout(() => validateInputs(), 100);
                    break;
                case 2:
                    content.innerHTML = getStep2Content();
                    renderCandidatesInWizard();
                    break;
                case 3:
                    content.innerHTML = getStep3Content();
                    renderSanitizationInWizard();
                    break;
                case 4:
                    content.innerHTML = getStep4Content();
                    renderReviewInWizard();
                    break;
                case 5:
                    content.innerHTML = getStep5Content();
                    break;
            }
        }

        function getStep1Content() {
            return `
                <h3>Configure Inputs</h3>
                
                <div class="input-group">
                    <label for="vaults">Vaults:</label>
                    <textarea id="vaults" rows="3" placeholder="v1, v2, v3" oninput="validateInputs()">v1,v2</textarea>
                </div>
                
                <div class="input-group">
                    <label for="tagsToAdd">Tags To Add (max 3):</label>
                    <textarea id="tagsToAdd" rows="3" placeholder="t1, t2, t3" oninput="validateInputs()">t1,t2</textarea>
                    <div id="tagsToAddError" class="validation-error" style="display: none;"></div>
                </div>
                
                <div class="input-group">
                    <label for="tagsToRemove">Tags To Remove (max 3):</label>
                    <textarea id="tagsToRemove" rows="3" placeholder="t3, t4" oninput="validateInputs()">t3</textarea>
                    <div id="tagsToRemoveError" class="validation-error" style="display: none;"></div>
                </div>
                
                <div id="conflictError" class="validation-error" style="display: none; margin-top: 10px;"></div>
                
                <div id="parsedInputsPreview" class="arrays-display" style="margin-top: 20px;">
                </div>
            `;
        }

        function getStep2Content() {
            return `
                <h3>Generated Candidates</h3>
                <p>Review the candidate pairs generated from your inputs. Conflicts (same vault/tag in both add and remove) are resolved by preferring remove operations.</p>
                <div id="candidatesWizardContent">
                    <div class="empty-state">Generating candidates...</div>
                </div>
            `;
        }

        function getStep3Content() {
            return `
                <h3>Sanitization Process</h3>
                <p>Watch the sequential validation of each candidate pair. Failed pairs cause their entire vault to be removed from the batch.</p>
                <div id="sanitizationWizardContent">
                    <div class="empty-state">Running sanitization...</div>
                </div>
            `;
        }

        function getStep4Content() {
            return `
                <h3>Review Results</h3>
                <p>Review the final valid pairs and any removed vaults before applying changes.</p>
                <div id="reviewWizardContent">
                    <div class="empty-state">Preparing results...</div>
                </div>
            `;
        }

        function getStep5Content() {
            return `
                <h3>Changes Applied</h3>
                <p>Your changes have been applied to the attachments table. A new request has been created that you can approve or reject from the table.</p>
                <div id="applyWizardContent">
                    <div class="empty-state">Applying changes...</div>
                </div>
            `;
        }

        function nextStep() {
            if (currentWizardStep < maxSteps) {
                // Check validation for step 1
                if (currentWizardStep === 1 && !validateInputs()) {
                    return; // Don't proceed if validation fails
                }
                
                // Process current step before moving to next
                processCurrentStep();
                showWizardStep(currentWizardStep + 1);
            } else {
                // Apply changes on final step
                applyChangesFromWizard();
            }
        }

        function previousStep() {
            if (currentWizardStep > 1) {
                showWizardStep(currentWizardStep - 1);
            }
        }

        function resetWizard() {
            // Reset all data
            currentCandidates = [];
            currentValidPairs = [];
            currentRemovedVaults = [];
            currentSanitizationLog = [];

            // Go back to step 1
            showWizardStep(1);
        }

        function processCurrentStep() {
            switch (currentWizardStep) {
                case 1:
                    generateCandidatesInWizard();
                    break;
                case 2:
                    runSanitizationInWizard();
                    break;
                case 3:
                    // Sanitization already complete, just move to review
                    break;
                case 4:
                    // Review complete, prepare for apply
                    break;
            }
        }

        function generateCandidatesInWizard() {
            const vaultsStr = document.getElementById('vaults').value;
            const addTagsStr = document.getElementById('tagsToAdd').value;
            const removeTagsStr = document.getElementById('tagsToRemove').value;

            const vaults = parseList(vaultsStr);
            const addTags = parseList(addTagsStr);
            const removeTags = parseList(removeTagsStr);

            currentCandidates = buildCandidates(vaults, addTags, removeTags);

            // Update parsed inputs preview in step 1
            const preview = document.getElementById('parsedInputsPreview');
            if (preview) {
                preview.innerHTML = `
                    <div><strong>Vaults:</strong> [${vaults.map(v => `"${v}"`).join(', ')}]</div>
                    <div><strong>Tags To Add:</strong> [${addTags.map(t => `"${t}"`).join(', ')}]</div>
                    <div><strong>Tags To Remove:</strong> [${removeTags.map(t => `"${t}"`).join(', ')}]</div>
                `;
            }
        }

        function runSanitizationInWizard() {
            const result = sanitizeCandidates(currentCandidates, currentAttachments);
            currentValidPairs = result.validPairs;
            currentRemovedVaults = result.removedVaults;
            currentSanitizationLog = result.log;
        }

        function applyChangesFromWizard() {
            const wizardContent = document.getElementById('wizardContent');
            const content = document.getElementById('applyWizardContent');

            // Start applying animation
            wizardContent.classList.add('wizard-applying');
            content.innerHTML = `
                <div style="background-color: #e3f2fd; border: 1px solid #bbdefb; border-radius: 6px; padding: 15px; margin-bottom: 20px;">
                    <h4 style="color: #1565c0; margin: 0 0 10px 0;">
                        <span class="applying-spinner"></span>Applying Changes...
                    </h4>
                    <p style="color: #1565c0; margin: 0;">Processing your request and updating the attachments table.</p>
                </div>
            `;

            // Simulate processing time and then apply changes
            setTimeout(() => {
                if (currentValidPairs.length > 0) {
                    currentAttachments = applyValidPairs(currentValidPairs, currentAttachments);
                    renderAttachmentsTable();

                    // Add success animation to table area
                    const tableArea = document.querySelector('.table-area');
                    tableArea.classList.add('success-bounce');

                    // Show completion message
                    const reqIds = [...new Set(currentAttachments.filter(att => att.reqId).map(att => att.reqId))];
                    const latestReqId = reqIds[reqIds.length - 1];

                    content.innerHTML = `
                        <div style="background-color: #d4edda; border: 1px solid #c3e6cb; border-radius: 6px; padding: 15px; margin-bottom: 20px;">
                            <h4 style="color: #155724; margin: 0 0 10px 0;">âœ… Changes Applied Successfully</h4>
                            <p style="color: #155724; margin: 0;">
                                ${currentValidPairs.length} pair(s) have been applied as request <strong>${latestReqId}</strong>.
                                Click on the request ID in the attachments table to review and approve/reject the changes.
                            </p>
                        </div>
                        <div>
                            <h4>Applied Changes:</h4>
                            <ul>
                                ${currentValidPairs.map(pair => `
                                    <li>${pair.action} ${pair.tagId} ${pair.action === 'add' ? 'to' : 'from'} vault ${pair.vaultId}</li>
                                `).join('')}
                            </ul>
                        </div>
                    `;

                    // Clean up animations
                    setTimeout(() => {
                        wizardContent.classList.remove('wizard-applying');
                        tableArea.classList.remove('success-bounce');
                    }, 1000);
                } else {
                    content.innerHTML = `
                        <div style="background-color: #fff3cd; border: 1px solid #ffeaa7; border-radius: 6px; padding: 15px;">
                            <h4 style="color: #856404; margin: 0 0 10px 0;">âš ï¸ No Changes Applied</h4>
                            <p style="color: #856404; margin: 0;">No valid pairs were found. All candidates were filtered out during sanitization.</p>
                        </div>
                    `;
                    wizardContent.classList.remove('wizard-applying');
                }
            }, 1500); // 1.5 second delay to show the applying animation
        }

        function renderCandidatesInWizard() {
            const container = document.getElementById('candidatesWizardContent');
            if (currentCandidates.length === 0) {
                container.innerHTML = '<div class="empty-state">No candidates generated</div>';
                return;
            }

            const table = `
                <table>
                    <thead>
                        <tr>
                            <th>Vault ID</th>
                            <th>Tag ID</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${currentCandidates.map(c => `
                            <tr>
                                <td>${c.vaultId}</td>
                                <td>${c.tagId}</td>
                                <td>${c.action}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;
            container.innerHTML = table;
        }

        function renderSanitizationInWizard() {
            const container = document.getElementById('sanitizationWizardContent');
            if (currentSanitizationLog.length === 0) {
                container.innerHTML = '<div class="empty-state">Running sanitization...</div>';
                return;
            }

            const logEntries = currentSanitizationLog.map(entry => {
                if (entry.vaultRemoved) {
                    return `<div class="log-entry vault-removed">Step ${entry.step}: ${entry.reason}</div>`;
                } else {
                    const cssClass = entry.status === 'PASS' ? 'pass' : 'fail';
                    const candidateStr = `{${entry.candidate.vaultId}, ${entry.candidate.tagId}, ${entry.candidate.action}}`;
                    return `<div class="log-entry ${cssClass}">Step ${entry.step}: ${candidateStr} â†’ ${entry.status} (${entry.reason})</div>`;
                }
            }).join('');

            container.innerHTML = `<div class="log-container">${logEntries}</div>`;
        }

        function renderReviewInWizard() {
            const container = document.getElementById('reviewWizardContent');

            let validPairsHtml = '';
            if (currentValidPairs.length > 0) {
                validPairsHtml = `
                    <h4>Valid Pairs (${currentValidPairs.length})</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Vault ID</th>
                                <th>Tag ID</th>
                                <th>Action</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${currentValidPairs.map(p => `
                                <tr>
                                    <td>${p.vaultId}</td>
                                    <td>${p.tagId}</td>
                                    <td>${p.action}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                `;
            } else {
                validPairsHtml = '<h4>Valid Pairs</h4><div class="empty-state">No valid pairs</div>';
            }

            let removedVaultsHtml = '';
            if (currentRemovedVaults.length > 0) {
                removedVaultsHtml = `<div class="removed-vaults" style="margin-top: 20px;">Removed vaults: ${currentRemovedVaults.join(', ')}</div>`;
            }

            container.innerHTML = validPairsHtml + removedVaultsHtml;
        }

        function validateInputs() {
            const vaultsEl = document.getElementById('vaults');
            const addTagsEl = document.getElementById('tagsToAdd');
            const removeTagsEl = document.getElementById('tagsToRemove');

            if (!vaultsEl || !addTagsEl || !removeTagsEl) return true;

            const vaults = parseList(vaultsEl.value);
            const addTags = parseList(addTagsEl.value);
            const removeTags = parseList(removeTagsEl.value);

            let isValid = true;

            // Clear previous validation styles
            addTagsEl.classList.remove('invalid');
            removeTagsEl.classList.remove('invalid');

            // Hide all error messages
            const addError = document.getElementById('tagsToAddError');
            const removeError = document.getElementById('tagsToRemoveError');
            const conflictError = document.getElementById('conflictError');

            if (addError) addError.style.display = 'none';
            if (removeError) removeError.style.display = 'none';
            if (conflictError) conflictError.style.display = 'none';

            // Validate tag count limits
            if (addTags.length > 3) {
                addTagsEl.classList.add('invalid');
                if (addError) {
                    addError.textContent = `Too many tags (${addTags.length}/3). Maximum 3 tags allowed.`;
                    addError.style.display = 'block';
                }
                isValid = false;
            }

            if (removeTags.length > 3) {
                removeTagsEl.classList.add('invalid');
                if (removeError) {
                    removeError.textContent = `Too many tags (${removeTags.length}/3). Maximum 3 tags allowed.`;
                    removeError.style.display = 'block';
                }
                isValid = false;
            }

            // Validate no tag appears in both arrays
            const conflicts = addTags.filter(tag => removeTags.includes(tag));
            if (conflicts.length > 0) {
                addTagsEl.classList.add('invalid');
                removeTagsEl.classList.add('invalid');
                if (conflictError) {
                    conflictError.textContent = `Tags appear in both add and remove: [${conflicts.join(', ')}]. A tag cannot be both added and removed.`;
                    conflictError.style.display = 'block';
                }
                isValid = false;
            }

            // Update preview
            updateInputPreview();

            // Update navigation button state
            updateNextButtonState(isValid);

            return isValid;
        }

        function updateNextButtonState(isValid) {
            const nextBtn = document.getElementById('nextBtn');
            if (nextBtn && currentWizardStep === 1) {
                nextBtn.disabled = !isValid;
                if (!isValid) {
                    nextBtn.classList.add('btn-secondary');
                    nextBtn.classList.remove('btn-primary');
                } else {
                    nextBtn.classList.add('btn-primary');
                    nextBtn.classList.remove('btn-secondary');
                }
            }
        }

        function updateInputPreview() {
            const vaultsEl = document.getElementById('vaults');
            const addTagsEl = document.getElementById('tagsToAdd');
            const removeTagsEl = document.getElementById('tagsToRemove');
            const previewEl = document.getElementById('parsedInputsPreview');

            if (!vaultsEl || !addTagsEl || !removeTagsEl || !previewEl) return;

            const vaults = parseList(vaultsEl.value);
            const addTags = parseList(addTagsEl.value);
            const removeTags = parseList(removeTagsEl.value);

            previewEl.innerHTML = `
                <div><strong>Vaults:</strong> [${vaults.map(v => `"${v}"`).join(', ')}]</div>
                <div><strong>Tags To Add:</strong> [${addTags.map(t => `"${t}"`).join(', ')}]</div>
                <div><strong>Tags To Remove:</strong> [${removeTags.map(t => `"${t}"`).join(', ')}]</div>
            `;
        }

        resetWizard()

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function () {
            initializeStarterData();
            showWizardStep(1);
        });
    </script>
</body>

</html>